<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üíé User Sync Diagnostic Tool</title>
    <style>
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #000;
            color: #0f0;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
            border: 2px solid #0f0;
            padding: 20px;
            border-radius: 10px;
        }
        .section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #333;
            border-radius: 5px;
            background: #111;
        }
        .button {
            background: #0f0;
            color: #000;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            margin: 10px 5px;
            border-radius: 5px;
            font-weight: bold;
            font-family: inherit;
        }
        .button:hover {
            background: #0c0;
        }
        .button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        .log {
            background: #000;
            border: 1px solid #333;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .stat-box {
            border: 2px solid #0f0;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
        }
        .stat-number {
            font-size: 3em;
            font-weight: bold;
            margin: 10px 0;
        }
        .critical {
            color: #f00;
            border-color: #f00;
        }
        .success {
            color: #0f0;
            border-color: #0f0;
        }
        .warning {
            color: #fa0;
            border-color: #fa0;
        }
        .button.warning {
            background: #fa0;
            color: #000;
        }
        .button.warning:hover {
            background: #dc0;
        }
        .user-list {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #333;
            padding: 10px;
            background: #111;
        }
        .user-item {
            padding: 5px;
            margin: 2px 0;
            border-left: 3px solid #0f0;
            padding-left: 10px;
        }
        .missing-user {
            border-left-color: #f00;
            background: #220;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üíé DIAMOND LEVEL USER SYNC DIAGNOSTIC üíé</h1>
            <h2>üî• Firebase Users ‚Üî Pool Members Sync Tool üî•</h2>
        </div>

        <div class="section">
            <h3>üîê AUTHENTICATION</h3>
            <button class="button" onclick="signInWithGoogle()" id="signInBtn">üîë SIGN IN WITH GOOGLE</button>
            <button class="button" onclick="signOut()" id="signOutBtn" disabled>üö™ SIGN OUT</button>
            <div id="userStatus" style="margin: 10px 0; padding: 10px; border: 1px solid #333; background: #111;">
                <strong>Status:</strong> <span id="authStatus">Not authenticated</span><br>
                <strong>User:</strong> <span id="currentUser">None</span>
            </div>
        </div>

        <div class="section">
            <h3>üéØ DIAGNOSTIC ACTIONS</h3>
            <button class="button" onclick="analyzeUsers()" id="analyzeBtn" disabled>üîç ANALYZE USER DISCREPANCY</button>
            <button class="button" onclick="syncMissingUsers()" id="syncBtn" disabled>‚ö° SYNC MISSING USERS TO POOL</button>
            <button class="button" onclick="verifySync()" id="verifyBtn" disabled>‚úÖ VERIFY SYNC COMPLETE</button>
            <button class="button" onclick="clearLog()">üßπ CLEAR LOG</button>
        </div>

        <div class="section">
            <h3>üßπ CLEANUP ACTIONS</h3>
            <button class="button warning" onclick="checkDanglingUserPicks()" id="checkPicksBtn" disabled>üîç CHECK DANGLING USERS FOR PICKS</button>
            <button class="button warning" onclick="cleanupDanglingPoolMembers()" id="cleanupDanglingBtn" disabled>üßπ CLEANUP DANGLING POOL MEMBERS</button>
            <button class="button warning" onclick="deleteProblemUsers()" id="deleteProblemBtn" disabled>üî• DELETE PROBLEM USERS NOW</button>
            <button class="button warning" onclick="cleanupOrphanedUsers()" id="cleanupBtn" disabled>üóëÔ∏è CLEANUP ORPHANED USERS</button>
            <p style="font-size: 0.9em; color: #fa0; margin: 10px 0;">
                üîç Check Picks: Verify if dangling users have picks data before cleanup<br>
                üßπ Dangling: Removes pool members who no longer exist in Firestore users<br>
                üî• Problem Users: Deletes specific problematic users from Firestore<br>
                ‚ö†Ô∏è Cleanup: Manual removal of users that no longer exist in Firebase Authentication
            </p>
        </div>

        <div class="stats">
            <div class="stat-box" id="firebaseUsersBox">
                <h3>üî• Firebase Users</h3>
                <div class="stat-number" id="firebaseCount">--</div>
                <div>Total System Users</div>
            </div>
            <div class="stat-box" id="poolMembersBox">
                <h3>üèä Pool Members</h3>
                <div class="stat-number" id="poolCount">--</div>
                <div>Pool Members Count</div>
            </div>
            <div class="stat-box" id="discrepancyBox">
                <h3>‚ö†Ô∏è Missing Users</h3>
                <div class="stat-number" id="missingCount">--</div>
                <div>Users Not In Pool</div>
            </div>
        </div>

        <div class="section">
            <h3>üìã DIAGNOSTIC LOG</h3>
            <div class="log" id="diagnosticLog">üíé Ready to diagnose user sync issues...\nüéØ Click ANALYZE to begin\n</div>
        </div>

        <div class="section">
            <h3>üö´ MISSING USERS (Not in Pool)</h3>
            <div class="user-list" id="missingUsersList">
                Click ANALYZE to see missing users...
            </div>
        </div>

        <div class="section">
            <h3>‚úÖ POOL MEMBERS (Current)</h3>
            <div class="user-list" id="poolMembersList">
                Click ANALYZE to see pool members...
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js';
        import { getFirestore, collection, getDocs, doc, getDoc, setDoc, deleteDoc } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js';
        import { getAuth, signInWithPopup, GoogleAuthProvider, signOut as firebaseSignOut, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js';

        const firebaseConfig = {
            apiKey: "AIzaSyDAF1MbAhL2uPIVUGMDlXvCqtknUUCX5Gw",
            authDomain: "nerdfootball.firebaseapp.com",
            projectId: "nerdfootball",
            storageBucket: "nerdfootball.appspot.com",
            messagingSenderId: "969304790725",
            appId: "1:969304790725:web:892df38db0b0e62bde02ac",
            measurementId: "G-8RVRHE3HRC"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const provider = new GoogleAuthProvider();

        let analysisData = null;
        let currentUser = null;

        // Global functions for buttons
        window.analyzeUsers = analyzeUsers;
        window.syncMissingUsers = syncMissingUsers;
        window.verifySync = verifySync;
        window.clearLog = clearLog;
        window.signInWithGoogle = signInWithGoogle;
        window.signOut = signOut;
        window.cleanupOrphanedUsers = cleanupOrphanedUsers;
        window.deleteProblemUsers = deleteProblemUsers;
        window.cleanupDanglingPoolMembers = cleanupDanglingPoolMembers;
        window.checkDanglingUserPicks = checkDanglingUserPicks;

        function log(message, type = 'info') {
            const logDiv = document.getElementById('diagnosticLog');
            const timestamp = new Date().toLocaleTimeString();
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : 'üìç';
            logDiv.textContent += `${timestamp} ${prefix} ${message}\n`;
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        function clearLog() {
            document.getElementById('diagnosticLog').textContent = 'üíé Log cleared - Ready for new diagnostic...\n';
        }

        // Authentication functions
        async function signInWithGoogle() {
            try {
                log('üîë Signing in with Google...', 'info');
                const result = await signInWithPopup(auth, provider);
                log(`‚úÖ Signed in as: ${result.user.displayName}`, 'success');
            } catch (error) {
                log(`‚ùå Sign in failed: ${error.message}`, 'error');
            }
        }

        async function signOut() {
            try {
                await firebaseSignOut(auth);
                log('‚úÖ Signed out successfully', 'success');
            } catch (error) {
                log(`‚ùå Sign out failed: ${error.message}`, 'error');
            }
        }

        // Update UI based on auth state
        function updateAuthUI(user) {
            const signInBtn = document.getElementById('signInBtn');
            const signOutBtn = document.getElementById('signOutBtn');
            const analyzeBtn = document.getElementById('analyzeBtn');
            const verifyBtn = document.getElementById('verifyBtn');
            const cleanupBtn = document.getElementById('cleanupBtn');
            const deleteProblemBtn = document.getElementById('deleteProblemBtn');
            const cleanupDanglingBtn = document.getElementById('cleanupDanglingBtn');
            const checkPicksBtn = document.getElementById('checkPicksBtn');
            const authStatus = document.getElementById('authStatus');
            const currentUserSpan = document.getElementById('currentUser');

            if (user) {
                signInBtn.disabled = true;
                signOutBtn.disabled = false;
                analyzeBtn.disabled = false;
                verifyBtn.disabled = false;
                cleanupBtn.disabled = false;
                deleteProblemBtn.disabled = false;
                cleanupDanglingBtn.disabled = false;
                checkPicksBtn.disabled = false;
                authStatus.textContent = 'Authenticated';
                authStatus.style.color = '#0f0';
                currentUserSpan.textContent = user.displayName || user.email;
                currentUser = user;
                log(`üîê Authentication verified: ${user.displayName}`, 'success');
            } else {
                signInBtn.disabled = false;
                signOutBtn.disabled = true;
                analyzeBtn.disabled = true;
                verifyBtn.disabled = true;
                cleanupBtn.disabled = true;
                deleteProblemBtn.disabled = true;
                cleanupDanglingBtn.disabled = true;
                checkPicksBtn.disabled = true;
                document.getElementById('syncBtn').disabled = true;
                authStatus.textContent = 'Not authenticated';
                authStatus.style.color = '#f00';
                currentUserSpan.textContent = 'None';
                currentUser = null;
                log('üîí Please sign in to use diagnostic tools', 'warning');
            }
        }

        // Listen for auth state changes
        onAuthStateChanged(auth, (user) => {
            updateAuthUI(user);
        });

        async function analyzeUsers() {
            if (!currentUser) {
                log('‚ùå Please sign in first to analyze users', 'error');
                return;
            }

            log('üî• STARTING CRITICAL USER ANALYSIS...', 'info');
            
            try {
                // Clear previous stats
                document.getElementById('firebaseCount').textContent = '...';
                document.getElementById('poolCount').textContent = '...';
                document.getElementById('missingCount').textContent = '...';

                // Get all Firebase users
                log('üìç Fetching all Firebase users...');
                const usersPath = 'artifacts/nerdfootball/public/data/nerdfootball_users';
                const usersSnap = await getDocs(collection(db, usersPath));
                const firebaseUsers = {};
                
                usersSnap.docs.forEach(doc => {
                    // Skip ghost user
                    if (doc.id === 'okl4sw2aDhW3yKpOfOwe5lH7OQj1') {
                        log(`üö´ SKIPPING GHOST USER: ${doc.id}`, 'warning');
                        return;
                    }
                    firebaseUsers[doc.id] = doc.data();
                });

                log(`‚úÖ Found ${Object.keys(firebaseUsers).length} Firebase users (excluding ghost)`);
                document.getElementById('firebaseCount').textContent = Object.keys(firebaseUsers).length;

                // Get pool members
                log('üìç Fetching pool members...');
                const poolId = 'nerduniverse-2025';
                const poolMembersPath = `artifacts/nerdfootball/pools/${poolId}/metadata/members`;
                const poolMembersDoc = await getDoc(doc(db, poolMembersPath));
                
                const poolMembers = poolMembersDoc.exists() ? poolMembersDoc.data() : {};
                log(`‚úÖ Found ${Object.keys(poolMembers).length} pool members`);
                document.getElementById('poolCount').textContent = Object.keys(poolMembers).length;

                // Find missing users
                const missingUsers = [];
                Object.entries(firebaseUsers).forEach(([uid, userData]) => {
                    if (!poolMembers[uid]) {
                        missingUsers.push({ id: uid, data: userData });
                    }
                });

                log(`üéØ Found ${missingUsers.length} users missing from pool`);
                document.getElementById('missingCount').textContent = missingUsers.length;

                // Update UI styling based on results
                const discrepancyBox = document.getElementById('discrepancyBox');
                const syncBtn = document.getElementById('syncBtn');
                
                if (missingUsers.length === 0) {
                    discrepancyBox.className = 'stat-box success';
                    syncBtn.disabled = true;
                    log('üèÜ PERFECT! All users are in pool - no sync needed', 'success');
                } else {
                    discrepancyBox.className = 'stat-box critical';
                    syncBtn.disabled = false;
                    log(`‚ö†Ô∏è CRITICAL: ${missingUsers.length} users need to be added to pool`, 'warning');
                }

                // Display missing users
                const missingList = document.getElementById('missingUsersList');
                if (missingUsers.length === 0) {
                    missingList.innerHTML = '<div class="user-item success">üèÜ No missing users - Perfect sync!</div>';
                } else {
                    missingList.innerHTML = missingUsers.map(user => 
                        `<div class="user-item missing-user">
                            <strong>${user.data.displayName || user.data.email || 'Unknown'}</strong> (${user.id})<br>
                            <small>Email: ${user.data.email || 'N/A'}</small>
                        </div>`
                    ).join('');
                }

                // Display pool members
                const poolList = document.getElementById('poolMembersList');
                poolList.innerHTML = Object.entries(poolMembers).map(([uid, userData]) => 
                    `<div class="user-item">
                        <strong>${userData.displayName || userData.email || 'Unknown'}</strong> (${uid})<br>
                        <small>Role: ${userData.role} | Email: ${userData.email || 'N/A'}</small>
                    </div>`
                ).join('');

                // Store analysis data for sync
                analysisData = {
                    firebaseUsers,
                    poolMembers,
                    missingUsers,
                    poolId,
                    poolMembersPath
                };

                log('‚úÖ ANALYSIS COMPLETE!', 'success');

            } catch (error) {
                log(`‚ùå ANALYSIS ERROR: ${error.message}`, 'error');
                console.error('Analysis error:', error);
            }
        }

        async function syncMissingUsers() {
            if (!currentUser) {
                log('‚ùå Please sign in first to sync users', 'error');
                return;
            }

            if (!analysisData || analysisData.missingUsers.length === 0) {
                log('‚ùå No analysis data or missing users found. Run ANALYZE first.', 'error');
                return;
            }

            log('üî• STARTING CRITICAL USER SYNC...', 'info');
            
            try {
                const { poolMembers, missingUsers, poolMembersPath } = analysisData;
                
                log(`üìç Adding ${missingUsers.length} missing users to pool...`);

                // Create updated pool members
                const updatedMembers = { ...poolMembers };
                
                missingUsers.forEach(user => {
                    updatedMembers[user.id] = {
                        displayName: user.data.displayName || user.data.email || 'Unknown User',
                        email: user.data.email || '',
                        role: 'member',
                        joinedAt: new Date().toISOString(),
                        addedBy: 'user-sync-tool',
                        uid: user.id,
                        ...user.data
                    };
                    log(`‚ûï Adding: ${user.data.displayName || user.data.email} (${user.id})`);
                });

                // Update pool members document
                log('üìç Updating pool members document...');
                await setDoc(doc(db, poolMembersPath), updatedMembers);

                log(`‚úÖ SUCCESS! Pool members updated`);
                log(`üìä Pool now has ${Object.keys(updatedMembers).length} total members`);

                // Update pool config
                const poolConfigPath = `artifacts/nerdfootball/pools/${analysisData.poolId}/metadata/config`;
                const poolConfigDoc = await getDoc(doc(db, poolConfigPath));
                
                if (poolConfigDoc.exists()) {
                    const currentConfig = poolConfigDoc.data();
                    await setDoc(doc(db, poolConfigPath), {
                        ...currentConfig,
                        memberCount: Object.keys(updatedMembers).length,
                        lastUpdated: new Date().toISOString(),
                        lastSync: new Date().toISOString()
                    });
                    log('‚úÖ Updated pool config member count');
                }

                log('üèÜ SYNC COMPLETE! All users now in pool', 'success');
                
                // Re-run analysis to verify
                setTimeout(() => {
                    log('üîÑ Re-analyzing to verify sync...');
                    analyzeUsers();
                }, 1000);

            } catch (error) {
                log(`‚ùå SYNC ERROR: ${error.message}`, 'error');
                console.error('Sync error:', error);
            }
        }

        async function verifySync() {
            if (!currentUser) {
                log('‚ùå Please sign in first to verify sync', 'error');
                return;
            }

            log('üîç VERIFYING SYNC STATUS...', 'info');
            await analyzeUsers();
            
            if (analysisData && analysisData.missingUsers.length === 0) {
                log('üèÜ VERIFICATION SUCCESS: All users synced!', 'success');
            } else {
                log('‚ö†Ô∏è VERIFICATION: Issues still exist', 'warning');
            }
        }

        async function cleanupOrphanedUsers() {
            if (!currentUser) {
                log('‚ùå Please sign in first to cleanup orphaned users', 'error');
                return;
            }

            log('üóëÔ∏è STARTING MANUAL USER CLEANUP...', 'warning');
            
            try {
                // Get all Firebase users from Firestore
                log('üìç Fetching all Firestore users...');
                const usersPath = 'artifacts/nerdfootball/public/data/nerdfootball_users';
                const usersSnap = await getDocs(collection(db, usersPath));
                
                log(`‚úÖ Found ${usersSnap.size} users in Firestore`);
                
                // Show ALL users for manual review
                const allUsers = [];
                usersSnap.docs.forEach(userDoc => {
                    const userData = userDoc.data();
                    allUsers.push({
                        id: userDoc.id,
                        data: userData,
                        displayName: userData.displayName || 'NO NAME',
                        email: userData.email || 'NO EMAIL'
                    });
                });
                
                // Sort by ID for consistency
                allUsers.sort((a, b) => a.id.localeCompare(b.id));
                
                log('\nüìã ALL FIRESTORE USERS FOR MANUAL REVIEW:', 'info');
                allUsers.forEach((user, index) => {
                    const status = user.id === 'okl4sw2aDhW3yKpOfOwe5lH7OQj1' ? 'üëª GHOST' : 
                                  user.id === '6FYtDM1p9vOpLFbSkRjBGaqayzm1' ? 'üö´ PHANTOM' : '‚úÖ NORMAL';
                    log(`${index + 1}. ${status} ${user.id}`, 'info');
                    log(`   Name: ${user.displayName} | Email: ${user.email}`, 'info');
                });
                
                // Manual selection approach
                const userIdsToDelete = prompt(`üóëÔ∏è MANUAL USER CLEANUP\n\nEnter the USER IDs to delete (comma-separated):\n\nSuggested problematic users:\n‚Ä¢ 6FYtDM1p9vOpLFbSkRjBGaqayzm1 (phantom user)\n‚Ä¢ okl4sw2aDhW3yKpOfOwe5lH7OQj1 (ghost user)\n\nEnter IDs to delete:`);
                
                if (!userIdsToDelete) {
                    log('‚ùå No user IDs provided - cleanup cancelled', 'warning');
                    return;
                }
                
                // Parse and validate user IDs
                const idsToDelete = userIdsToDelete.split(',').map(id => id.trim()).filter(id => id.length > 0);
                
                if (idsToDelete.length === 0) {
                    log('‚ùå No valid user IDs provided - cleanup cancelled', 'warning');
                    return;
                }
                
                log(`üéØ Will delete ${idsToDelete.length} users:`, 'warning');
                idsToDelete.forEach(id => log(`  - ${id}`, 'warning'));
                
                const confirmDelete = confirm(`‚ö†Ô∏è FINAL CONFIRMATION\n\nYou are about to PERMANENTLY DELETE ${idsToDelete.length} users from Firestore:\n\n${idsToDelete.join('\n')}\n\nThis action cannot be undone!\n\nProceed with deletion?`);
                
                if (!confirmDelete) {
                    log('‚ùå User cancelled deletion', 'warning');
                    return;
                }
                
                // Delete specified users
                log('üóëÔ∏è Deleting specified users from Firestore...', 'warning');
                let deletedCount = 0;
                let errorCount = 0;
                
                for (const userId of idsToDelete) {
                    try {
                        // Check if user exists before deletion
                        const userExists = allUsers.some(u => u.id === userId);
                        if (!userExists) {
                            log(`‚ö†Ô∏è User ${userId} not found in Firestore - skipping`, 'warning');
                            continue;
                        }
                        
                        await deleteDoc(doc(db, usersPath, userId));
                        log(`‚úÖ Deleted user: ${userId}`, 'success');
                        deletedCount++;
                    } catch (error) {
                        log(`‚ùå Failed to delete user ${userId}: ${error.message}`, 'error');
                        errorCount++;
                    }
                }
                
                log(`üèÜ CLEANUP COMPLETE! Deleted: ${deletedCount}, Errors: ${errorCount}`, 'success');
                
                if (deletedCount > 0) {
                    log('üí° Run ANALYZE again to see updated user counts', 'info');
                }
                
            } catch (error) {
                log(`‚ùå CLEANUP ERROR: ${error.message}`, 'error');
                console.error('Cleanup error:', error);
            }
        }

        async function deleteProblemUsers() {
            if (!currentUser) {
                log('‚ùå Please sign in first to delete problem users', 'error');
                return;
            }

            const problemUsers = [
                '6FYtDM1p9vOpLFbSkRjBGaqayzm1', // Phantom user (deleted from auth)
                'okl4sw2aDhW3yKpOfOwe5lH7OQj1'  // Ghost user (known problematic)
            ];

            const confirmDelete = confirm('üî• DELETE PROBLEM USERS\n\nThis will permanently delete these 2 problematic users from Firestore:\n\n‚Ä¢ 6FYtDM1p9vOpLFbSkRjBGaqayzm1 (phantom user)\n‚Ä¢ okl4sw2aDhW3yKpOfOwe5lH7OQj1 (ghost user)\n\nProceed with deletion?');
            
            if (!confirmDelete) {
                log('‚ùå User cancelled problem user deletion', 'warning');
                return;
            }

            log('üî• DELETING PROBLEM USERS...', 'warning');
            
            try {
                const usersPath = 'artifacts/nerdfootball/public/data/nerdfootball_users';
                let deletedCount = 0;
                let notFoundCount = 0;

                for (const userId of problemUsers) {
                    try {
                        log(`üóëÔ∏è Deleting ${userId}...`);
                        
                        // Check if user exists first
                        const userDoc = await getDoc(doc(db, usersPath, userId));
                        
                        if (!userDoc.exists()) {
                            log(`‚ö†Ô∏è User ${userId} not found - already deleted`, 'warning');
                            notFoundCount++;
                            continue;
                        }
                        
                        const userData = userDoc.data();
                        log(`Found: ${userData.displayName || userData.email || 'No name'} (${userId})`);
                        
                        // Delete the user
                        await deleteDoc(doc(db, usersPath, userId));
                        log(`‚úÖ Successfully deleted: ${userId}`, 'success');
                        deletedCount++;
                        
                    } catch (error) {
                        log(`‚ùå Failed to delete ${userId}: ${error.message}`, 'error');
                    }
                }

                log(`üèÜ PROBLEM USER DELETION COMPLETE!`, 'success');
                log(`‚úÖ Deleted: ${deletedCount} users`, 'success');
                log(`‚ö†Ô∏è Not found: ${notFoundCount} users`, 'warning');
                
                if (deletedCount > 0) {
                    log('üí° Run ANALYZE again to see updated counts', 'info');
                }

            } catch (error) {
                log(`‚ùå DELETION ERROR: ${error.message}`, 'error');
                console.error('Deletion error:', error);
            }
        }

        async function cleanupDanglingPoolMembers() {
            if (!currentUser) {
                log('‚ùå Please sign in first to cleanup dangling pool members', 'error');
                return;
            }

            log('üßπ STARTING DANGLING POOL MEMBERS CLEANUP...', 'warning');
            
            try {
                // Get all Firestore users
                log('üìç Fetching Firestore users...');
                const usersPath = 'artifacts/nerdfootball/public/data/nerdfootball_users';
                const usersSnap = await getDocs(collection(db, usersPath));
                const firestoreUserIds = new Set();
                
                usersSnap.docs.forEach(doc => {
                    firestoreUserIds.add(doc.id);
                });
                
                log(`‚úÖ Found ${firestoreUserIds.size} users in Firestore`);

                // Get pool members
                log('üìç Fetching pool members...');
                const poolId = 'nerduniverse-2025';
                const poolMembersPath = `artifacts/nerdfootball/pools/${poolId}/metadata/members`;
                const poolMembersDoc = await getDoc(doc(db, poolMembersPath));
                
                if (!poolMembersDoc.exists()) {
                    log('‚ùå Pool members document not found', 'error');
                    return;
                }

                const poolMembers = poolMembersDoc.data();
                log(`‚úÖ Found ${Object.keys(poolMembers).length} pool members`);

                // Find dangling pool members (in pool but not in Firestore)
                const danglingMembers = [];
                Object.entries(poolMembers).forEach(([uid, userData]) => {
                    if (!firestoreUserIds.has(uid)) {
                        danglingMembers.push({
                            id: uid,
                            data: userData
                        });
                    }
                });

                log(`üéØ Found ${danglingMembers.length} dangling pool members`);

                if (danglingMembers.length === 0) {
                    log('‚úÖ No dangling pool members found - pool is clean!', 'success');
                    return;
                }

                // Show dangling members
                log('\nüóëÔ∏è DANGLING POOL MEMBERS TO REMOVE:', 'warning');
                danglingMembers.forEach(member => {
                    const name = member.data.displayName || member.data.email || 'No name';
                    log(`  - ${member.id}: ${name}`, 'warning');
                });

                const confirmDelete = confirm(`üßπ CLEANUP DANGLING POOL MEMBERS\n\nFound ${danglingMembers.length} pool members who no longer exist in Firestore:\n\n${danglingMembers.map(m => `‚Ä¢ ${m.id}: ${m.data.displayName || m.data.email || 'No name'}`).join('\n')}\n\nRemove them from the pool?`);
                
                if (!confirmDelete) {
                    log('‚ùå User cancelled dangling cleanup', 'warning');
                    return;
                }

                // Remove dangling members from pool
                log('üßπ Removing dangling members from pool...', 'warning');
                const cleanedPoolMembers = { ...poolMembers };
                
                danglingMembers.forEach(member => {
                    delete cleanedPoolMembers[member.id];
                    log(`‚úÖ Removed dangling member: ${member.id}`, 'success');
                });

                // Update pool members document
                await setDoc(doc(db, poolMembersPath), cleanedPoolMembers);
                log('‚úÖ Updated pool members document', 'success');

                // Update pool config member count
                const poolConfigPath = `artifacts/nerdfootball/pools/${poolId}/metadata/config`;
                const poolConfigDoc = await getDoc(doc(db, poolConfigPath));
                
                if (poolConfigDoc.exists()) {
                    const currentConfig = poolConfigDoc.data();
                    await setDoc(doc(db, poolConfigPath), {
                        ...currentConfig,
                        memberCount: Object.keys(cleanedPoolMembers).length,
                        lastUpdated: new Date().toISOString(),
                        lastCleanup: new Date().toISOString()
                    });
                    log('‚úÖ Updated pool config member count', 'success');
                }

                log(`üèÜ DANGLING CLEANUP COMPLETE!`, 'success');
                log(`üßπ Removed: ${danglingMembers.length} dangling members`, 'success');
                log(`üìä Pool now has: ${Object.keys(cleanedPoolMembers).length} members`, 'success');
                log('üí° Run ANALYZE again to see updated counts', 'info');

            } catch (error) {
                log(`‚ùå DANGLING CLEANUP ERROR: ${error.message}`, 'error');
                console.error('Dangling cleanup error:', error);
            }
        }

        async function checkDanglingUserPicks() {
            if (!currentUser) {
                log('‚ùå Please sign in first to check user picks', 'error');
                return;
            }

            const danglingUsers = [
                { id: 'RSj8SoyvF9NHOtbSi8uULvJpm6H2', name: 'Michael Rayfield' },
                { id: 'UiQyobvibJgXwEexUj6AhaUUg7P2', name: 'James Stewart' },
                { id: 'RThxWwOKm8fm52CHU5VUWIdMa7q2', name: 'Rey Gomez' }
            ];

            log('üîç CHECKING DANGLING USERS FOR PICKS DATA...', 'info');
            
            try {
                const poolId = 'nerduniverse-2025';
                const picksResults = {};

                for (const user of danglingUsers) {
                    log(`üìç Checking picks for: ${user.name} (${user.id})`);
                    
                    // Check multiple possible picks paths
                    const picksPaths = [
                        `artifacts/nerdfootball/pools/${poolId}/picks/${user.id}`,
                        `artifacts/nerdfootball/picks/${user.id}`,
                        `picks/${user.id}`,
                        `users/${user.id}/picks`
                    ];

                    let foundPicks = false;
                    const userPicksData = {};

                    for (const path of picksPaths) {
                        try {
                            const picksDoc = await getDoc(doc(db, path));
                            
                            if (picksDoc.exists()) {
                                const picksData = picksDoc.data();
                                const pickCount = Object.keys(picksData).length;
                                log(`  ‚úÖ Found ${pickCount} picks at: ${path}`, 'success');
                                userPicksData[path] = {
                                    exists: true,
                                    pickCount,
                                    samplePicks: Object.keys(picksData).slice(0, 3)
                                };
                                foundPicks = true;
                            }
                        } catch (error) {
                            // Silently continue - path doesn't exist or access denied
                        }
                    }

                    // Check if user appears in any picks collections
                    const collectionsToCheck = [
                        `artifacts/nerdfootball/pools/${poolId}/picks`,
                        `artifacts/nerdfootball/picks`
                    ];

                    for (const collectionPath of collectionsToCheck) {
                        try {
                            const picksSnapshot = await getDocs(collection(db, collectionPath));
                            
                            picksSnapshot.docs.forEach(docSnap => {
                                const data = docSnap.data();
                                if (docSnap.id === user.id || JSON.stringify(data).includes(user.id)) {
                                    log(`  ‚úÖ Found user data in collection: ${collectionPath}/${docSnap.id}`, 'success');
                                    userPicksData[`${collectionPath}/${docSnap.id}`] = {
                                        exists: true,
                                        isUserDoc: docSnap.id === user.id,
                                        mentionsUser: JSON.stringify(data).includes(user.id)
                                    };
                                    foundPicks = true;
                                }
                            });
                        } catch (error) {
                            // Silently continue
                        }
                    }

                    picksResults[user.id] = {
                        name: user.name,
                        hasPicks: foundPicks,
                        picksData: userPicksData
                    };

                    if (foundPicks) {
                        log(`üéØ ${user.name}: HAS PICKS DATA ‚ö†Ô∏è CAUTION BEFORE DELETION`, 'warning');
                    } else {
                        log(`‚úÖ ${user.name}: No picks found - safe to remove`, 'success');
                    }
                }

                log('\nüìä PICKS CHECK SUMMARY:', 'info');
                const usersWithPicks = Object.values(picksResults).filter(u => u.hasPicks);
                const usersWithoutPicks = Object.values(picksResults).filter(u => !u.hasPicks);

                if (usersWithPicks.length > 0) {
                    log(`‚ö†Ô∏è ${usersWithPicks.length} users have picks data - CAUTION before removing:`, 'warning');
                    usersWithPicks.forEach(u => log(`  - ${u.name}`, 'warning'));
                }

                if (usersWithoutPicks.length > 0) {
                    log(`‚úÖ ${usersWithoutPicks.length} users have no picks - safe to remove:`, 'success');
                    usersWithoutPicks.forEach(u => log(`  - ${u.name}`, 'success'));
                }

                if (usersWithPicks.length > 0) {
                    log('\nüí° RECOMMENDATION: Do NOT remove users with picks data to preserve game history', 'info');
                }

            } catch (error) {
                log(`‚ùå PICKS CHECK ERROR: ${error.message}`, 'error');
                console.error('Picks check error:', error);
            }
        }

        // Initialize page
        log('üíé User Sync Diagnostic Tool Ready', 'info');
        log('üîë Please sign in to begin diagnostics', 'warning');
    </script>
</body>
</html>