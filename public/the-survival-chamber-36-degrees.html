<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üèà The Survival Chamber - 36 Degrees</title>
    <script src="https://cdn.tailwindcss.com/3.4.0"></script>
    <script>
        // Suppress Tailwind CDN production warning
        if (typeof process === 'undefined') {
            window.process = { env: { NODE_ENV: 'development' } };
        }
        if (typeof window !== 'undefined') {
            window.process = { env: { NODE_ENV: 'production' } };
        }
        ['warn', 'error', 'log', 'info'].forEach(method => {
            const original = console[method];
            if (original) {
                console[method] = function(...args) {
                    const message = args.join(' ');
                    if (message.includes('tailwindcss.com') ||
                        message.includes('should not be used in production') ||
                        message.includes('cdn.tailwindcss.com') ||
                        message.includes('PostCSS plugin')) {
                        return; // Block production warnings
                    }
                    original.apply(console, args);
                };
            }
        });
        tailwind.config = {
            corePlugins: { preflight: true },
            content: ['./*.html', './*.js']
        }
    </script>
    <style>
        .survival-glow {
            box-shadow: 0 0 20px rgba(139, 69, 19, 0.5);
        }
        .eliminated {
            opacity: 0.7;
            background: transparent;
            border-left: 3px solid #ff0000;
        }
        .alive {
            background: transparent;
            border-left: 3px solid #00ff00;
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.2);
        }
        body {
            background: #000000;
        }

        html {
            background: #000000;
        }

        /* Terminal Header Styles */
        .header-terminal {
            position: relative;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            box-shadow: 0 2px 20px rgba(0, 255, 65, 0.1);
            z-index: 1000;
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999;
            opacity: 1.0;
            pointer-events: none;
        }

        .container {
            position: relative;
            z-index: 1001;
        }

        .terminal-window {
            background: rgba(26, 26, 26, 0.95);
            border: 1px solid #2a2a2a;
            backdrop-filter: blur(10px);
            box-shadow:
                0 0 20px rgba(0, 255, 65, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .neon-button {
            background: linear-gradient(45deg, #1a1a1a, #2a2a2a);
            border: 1px solid #00ff41;
            color: #00ff41;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            text-shadow: 0 0 5px rgba(0, 255, 65, 0.5);
        }

        .neon-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .neon-button:hover::before {
            left: 100%;
        }

        .neon-button:hover {
            background: linear-gradient(45deg, #2a2a2a, #3a3a3a);
            box-shadow:
                0 0 20px rgba(0, 255, 65, 0.3),
                inset 0 0 20px rgba(0, 255, 65, 0.1);
            transform: translateY(-2px);
        }

        .command-line::before {
            content: '$ ';
            color: #00d4ff;
            font-weight: bold;
        }

        .glow-text {
            text-shadow: 0 0 20px currentColor;
        }

        /* Terminal color utility classes */
        .terminal-text { color: #ffffff; }
        .terminal-accent { color: #00ff41; }
        .terminal-secondary { color: #00d4ff; }
        .terminal-danger { color: #ff4757; }
        .terminal-warning { color: #ffa502; }
        .terminal-muted { color: #888888; }
        .terminal-bg { background: #0a0a0a; }
        .terminal-surface { background: #1a1a1a; }
        .terminal-border { border-color: #2a2a2a; }
    </style>
    <script src="./js/utils/logger-compat.js"></script>
</head>
<body class="text-white min-h-screen">
    <!-- Matrix Background Effect -->
    <canvas id="matrix-bg" class="matrix-bg"></canvas>

    <!-- Header - Linux Terminal Style -->
    <header class="header-terminal">
        <div class="container mx-auto px-4 py-4">
            <div class="flex justify-between items-center flex-wrap gap-4">
                <!-- Logo and title - left aligned -->
                <a href="/" class="flex items-center gap-3 hover:opacity-80 transition-opacity cursor-pointer">
                    <img src="https://firebasestorage.googleapis.com/v0/b/nerdfootball.firebasestorage.app/o/nerdfootball-nerd-2025.png?alt=media&token=de5cef91-c70e-49bc-ba71-6f993439b11e" alt="NerdfootballAI Logo" class="h-8 md:h-10 w-auto">
                    <h1 class="text-3xl md:text-4xl font-bold terminal-text glow-text">NerdfootballAI</h1>
                </a>
                <!-- Right side elements -->
                <div class="flex items-center space-x-4">
                    <!-- Status Indicators -->
                    <div class="flex items-center space-x-2">
                        <!-- Game Update Indicator -->
                        <div id="game-update-indicator" class="hidden opacity-0 transition-opacity duration-500" title="Game Updated">
                            <span class="text-lg terminal-text">üèà</span>
                            <div class="live-game-data mt-1 space-y-0.5 text-xs terminal-muted"></div>
                        </div>
                        <!-- Cache Status Indicator -->
                        <div id="cache-status-indicator" class="relative group" title="Cache Status">
                            <div id="cache-status-glyph" class="w-3 h-3 rounded-full bg-terminal-accent animate-pulse cursor-pointer refreshing shadow-lg shadow-terminal-accent/30"></div>
                            <div class="absolute right-0 mt-2 w-48 bg-terminal-surface text-terminal-text text-xs rounded-lg p-2 opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none border border-terminal-border">
                                <div id="cache-status-tooltip">Refreshing cache...</div>
                            </div>
                        </div>

                        <!-- Theme Variant Toggle -->
                        <button id="theme-variant-toggle" class="ml-2 p-1 rounded bg-opacity-20 hover:bg-opacity-30 transition-all duration-200 text-sm terminal-text" title="Toggle Light/Dark Variant" style="display: none;">
                            üåô
                        </button>
                    </div>
                    <span class="text-sm font-medium terminal-secondary glow-text">v3.0</span>
                    <div class="flex items-center space-x-2 relative">
                        <!-- Logout Button -->
                        <button id="main-logout-btn" onclick="handleLogout()" class="neon-button px-3 py-1 text-xs rounded-md hover:bg-terminal-danger/20 transition-all duration-200 flex items-center space-x-1">
                            <span>üö™</span>
                            <span>Logout</span>
                        </button>

                        <!-- Hamburger Menu - Terminal Style -->
                        <button id="menu-btn" class="neon-button p-2 rounded-md">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path>
                            </svg>
                        </button>
                        <div id="menu-panel" class="absolute top-full right-0 mt-2 w-64 terminal-window rounded-md shadow-2xl hidden" style="z-index: 9999;">
                            <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="options-menu">
                                <!-- Main Features Only -->
                                <a href="./nerd-universe-grid.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200 bg-terminal-accent/20 border-l-4 border-terminal-accent" role="menuitem">
                                    <span class="text-lg">üìä</span>
                                    <span class="font-semibold">Picks Grid</span>
                                </a>
                                <a href="./index.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200" role="menuitem">
                                    <span class="text-lg">üéØ</span>
                                    <span>Make Picks</span>
                                </a>
                                <a href="./nerdSurvivor.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200" role="menuitem">
                                    <span class="text-lg">üèà</span>
                                    <span>Survivor Pool</span>
                                </a>
                                <a href="./the-survival-chamber-36-degrees.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200 bg-terminal-danger/20 border-l-4 border-yellow-400" role="menuitem">
                                    <span class="text-lg">‚öîÔ∏è</span>
                                    <span>The 36 Chambers</span>
                                </a>
                                <a href="./leaderboard.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200" role="menuitem">
                                    <span class="text-lg">üèÜ</span>
                                    <span>Season Leaderboard</span>
                                </a>
                                <a href="./weekly-leaderboard.html" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 flex items-center space-x-2 transition-all duration-200" role="menuitem">
                                    <span class="text-lg">üéÆ</span>
                                    <span>Weekly Leaderboard</span>
                                </a>

                                <!-- Account Section -->
                                <div class="border-t border-terminal-border my-1"></div>
                                <button id="logout-btn" onclick="handleLogout()" class="w-full text-left block px-4 py-2 text-sm terminal-text hover:bg-terminal-surface/50 hover:bg-terminal-danger/20 flex items-center space-x-2 transition-all duration-200" role="menuitem">
                                    <span class="text-lg">üö™</span>
                                    <span>Logout</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <div class="container mx-auto px-4 py-8">
        <!-- Header -->
        <div class="text-center mb-8">
            <h1 class="text-6xl font-bold mb-4 text-yellow-400 tracking-wider" style="text-shadow: 2px 2px 4px #000, 0 0 10px #ff6600;">
                ‚öîÔ∏è THE 36 CHAMBERS ‚öîÔ∏è
            </h1>
            <h2 class="text-3xl font-bold text-red-500 mb-2" style="text-shadow: 1px 1px 2px #000;">
                üó°Ô∏è DEATH BEFORE DISHONOR üó°Ô∏è
            </h2>
            <p class="text-orange-300 text-xl font-medium">Enter the Wu... But Few Survive</p>
            <p class="text-gray-400 mt-2">üêâ Protect Ya Neck - Week 3 Results üêâ</p>
        </div>

        <!-- Loading State -->
        <div id="loading" class="text-center">
            <div class="text-xl">‚ùÑÔ∏è Freezing survivor data...</div>
        </div>

        <!-- Error State -->
        <div id="error" class="text-center text-red-500 hidden">
            <div class="text-xl">üî• Chamber malfunction detected!</div>
            <div id="error-message" class="mt-2"></div>
        </div>

        <!-- Survivor Pool Stats -->
        <div id="stats" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8 hidden">
            <div class="p-6 rounded-lg text-center" style="background: rgba(0, 0, 0, 0.5); box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);">
                <div class="text-4xl font-bold text-green-400" id="alive-count">-</div>
                <div class="text-sm text-green-300 font-semibold">üêâ SURVIVORS</div>
            </div>
            <div class="p-6 rounded-lg text-center" style="background: rgba(0, 0, 0, 0.5); box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);">
                <div class="text-4xl font-bold text-red-400" id="eliminated-count">-</div>
                <div class="text-sm text-red-300 font-semibold">‚ò†Ô∏è FALLEN WARRIORS</div>
            </div>
            <div class="p-6 rounded-lg text-center" style="background: rgba(0, 0, 0, 0.5); box-shadow: 0 0 20px rgba(255, 165, 0, 0.3);">
                <div class="text-4xl font-bold text-orange-400" id="total-count">-</div>
                <div class="text-sm text-orange-300 font-semibold">‚öîÔ∏è ENTERED THE WU</div>
            </div>
        </div>


        <!-- Current Week Picks (shown when games have started) -->
        <div id="current-week-picks" class="mb-8 hidden">
            <div class="p-6 rounded-lg" style="background: rgba(0, 0, 0, 0.6); border: 2px solid #FFD700; box-shadow: 0 0 20px rgba(255, 215, 0, 0.3);">
                <h3 class="text-2xl font-bold text-yellow-400 mb-4" style="text-shadow: 1px 1px 2px #000;">
                    ‚öîÔ∏è Week <span id="current-week-number">4</span> Battle Picks
                </h3>
                <p class="text-yellow-300 mb-4">
                    <span id="current-picks-count">0</span> Alive Survivors have entered the chamber...
                </p>
                <div id="current-picks-list" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3">
                    <!-- Current week picks will be loaded here -->
                </div>
            </div>
        </div>

        <!-- Survivor Table -->
        <div id="survivor-table" class="hidden">
            <div class="rounded-lg overflow-hidden survival-glow" style="background: rgba(0, 0, 0, 0.4);">
                <div class="px-6 py-4" style="background: rgba(0, 0, 0, 0.6);">
                    <h3 class="text-2xl font-bold text-yellow-400" style="text-shadow: 1px 1px 2px #000;">
                        ‚öîÔ∏è THE FALLEN & THE SURVIVORS ‚öîÔ∏è
                    </h3>
                    <p class="text-red-400 text-sm mt-1">Week 3 Battle Results - Only The Strong Survive</p>
                </div>

                <div class="overflow-x-auto">
                    <table class="w-full">
                        <thead style="background: rgba(0, 0, 0, 0.7);">
                            <tr>
                                <th class="px-4 py-3 text-left text-yellow-400 font-bold">ü•∑ WARRIOR</th>
                                <th class="px-4 py-3 text-left text-yellow-400 font-bold">‚öîÔ∏è WEAPON OF CHOICE</th>
                                <th class="px-4 py-3 text-left text-yellow-400 font-bold">‚òØÔ∏è FATE</th>
                                <th class="px-4 py-3 text-left text-yellow-400 font-bold">üå°Ô∏è LIFE FORCE</th>
                            </tr>
                        </thead>
                        <tbody id="survivor-body">
                            <!-- Dynamic survivor data -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- Glassmorphism Game Button (appears when table scrolls out of view) -->
    <div id="game-button-container" class="fixed inset-0 flex items-center justify-center pointer-events-none opacity-0 transition-opacity duration-500" style="z-index: 2000;">
        <button id="game-button" class="pointer-events-auto px-12 py-6 text-2xl font-bold text-white rounded-2xl backdrop-blur-lg transition-all duration-300 hover:scale-110 animate-pulse"
                style="background: linear-gradient(135deg, rgba(0, 255, 255, 0.2), rgba(0, 136, 255, 0.3));
                       border: 2px solid rgba(255, 255, 255, 0.3);
                       box-shadow: 0 8px 32px 0 rgba(0, 255, 255, 0.37), inset 0 0 20px rgba(255, 255, 255, 0.1);">
            <span style="text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;">üéÆ LET'S GO PLAY A GAME! üöÄ</span>
        </button>
    </div>

    <!-- Hyperspace Star Animation Canvas -->
    <canvas id="hyperspace-canvas" class="fixed inset-0 pointer-events-none" style="opacity: 0; z-index: 1900; transition: opacity 0.5s;"></canvas>

    <!-- Hidden Space Shooter Game Zone (fixed overlay) -->
    <div id="game-zone" class="fixed inset-0 flex flex-col items-center justify-center" style="background: #000; opacity: 0; transition: opacity 1s ease-in-out; z-index: 1800; pointer-events: none;">
        <div class="w-full h-screen flex flex-col items-center justify-center" style="pointer-events: auto;">
            <!-- Game Header -->
            <div id="game-header" class="absolute top-8 text-center z-10">
                <h2 class="text-4xl font-bold text-cyan-400 mb-2" style="text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;">
                    üöÄ NERD DEFENDER üöÄ
                </h2>
                <div class="flex items-center justify-center space-x-6 text-lg">
                    <div class="text-green-400">Score: <span id="game-score" class="font-bold">0</span></div>
                    <div class="text-red-400">Lives: <span id="game-lives" class="font-bold">3</span></div>
                    <div class="text-yellow-400">Level: <span id="game-level" class="font-bold">1</span></div>
                </div>
                <div class="text-gray-400 text-sm mt-2">
                    ‚Üê ‚Üí Move | SPACE Shoot
                </div>
            </div>

            <!-- Exit Game Button (top right corner) -->
            <button id="exit-game-btn" class="fixed top-4 right-4 px-3 py-1 text-xs bg-red-600 hover:bg-red-500 text-white font-bold rounded transition-all duration-200" style="box-shadow: 0 0 10px rgba(255, 0, 0, 0.5); z-index: 20;">
                ‚úï
            </button>

            <!-- Game Canvas -->
            <canvas id="game-canvas" class="border-2 border-cyan-500" style="box-shadow: 0 0 30px rgba(0, 255, 255, 0.5); background: #000; max-width: 100vw; max-height: 60vh;"></canvas>

            <!-- Mobile Touch Controls -->
            <div id="mobile-controls" class="fixed bottom-8 left-0 right-0 flex items-center justify-between px-8" style="z-index: 25; max-width: 600px; margin: 0 auto;">
                <!-- Left Button -->
                <button id="btn-left" class="w-16 h-16 bg-cyan-600 bg-opacity-50 hover:bg-opacity-80 active:bg-opacity-100 text-white font-bold rounded-full text-2xl backdrop-blur-sm transition-all" style="box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); border: 2px solid rgba(0, 255, 255, 0.3);">
                    ‚óÄ
                </button>

                <!-- Shoot Button -->
                <button id="btn-shoot" class="w-20 h-20 bg-red-600 bg-opacity-50 hover:bg-opacity-80 active:bg-opacity-100 text-white font-bold rounded-full text-3xl backdrop-blur-sm transition-all" style="box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); border: 2px solid rgba(255, 0, 0, 0.3);">
                    üî•
                </button>

                <!-- Right Button -->
                <button id="btn-right" class="w-16 h-16 bg-cyan-600 bg-opacity-50 hover:bg-opacity-80 active:bg-opacity-100 text-white font-bold rounded-full text-2xl backdrop-blur-sm transition-all" style="box-shadow: 0 0 15px rgba(0, 255, 255, 0.5); border: 2px solid rgba(0, 255, 255, 0.3);">
                    ‚ñ∂
                </button>
            </div>

            <!-- Game Over Screen -->
            <div id="game-over" class="absolute inset-0 flex items-center justify-center hidden" style="background: rgba(0, 0, 0, 0.9);">
                <div class="text-center">
                    <h3 class="text-6xl font-bold text-red-500 mb-4" style="text-shadow: 0 0 20px #ff0000;">GAME OVER</h3>
                    <p class="text-2xl text-cyan-400 mb-2">Final Score: <span id="final-score" class="font-bold">0</span></p>
                    <p class="text-lg text-gray-400 mb-6">Scroll back up to return to the chamber</p>
                    <button id="restart-game" class="px-8 py-3 bg-cyan-600 hover:bg-cyan-500 text-white font-bold rounded-lg transition-all duration-200" style="box-shadow: 0 0 15px rgba(0, 255, 255, 0.5);">
                        RESTART GAME
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { getFirebaseConfig } from './js/config/firebase-config.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Initialize Firebase
        const app = initializeApp(getFirebaseConfig());
        const auth = getAuth(app);
        const db = getFirestore(app);

        // Make Firebase functions available globally for use in other functions
        window.db = db;
        window.doc = doc;
        window.getDoc = getDoc;
        window.setDoc = setDoc;
        window.deleteDoc = deleteDoc;

        let survivorsData = [];
        let currentUser = null;

        // Make signOut available globally for logout functionality
        window.signOut = signOut;

        // Admin UIDs (same as other pages)
        const ADMIN_UIDS = [
            'WxSPmEildJdqs6T5hIpBUZrscwt2', // tonyweeg@gmail.com
            'CX0etIyJbGg33nmHCo4eezPWrsr2',
            'sm17z8ovI8NAGmyQvogD86lIurr1',
            'dN91P1yGG4YBttxeGWmpAM2xhl22'
        ];

        // Authentication check
        onAuthStateChanged(auth, (user) => {
            currentUser = user;
            const userDisplay = document.getElementById('user-display');

            if (user) {
                logger.auth('üîê User authenticated:', user.email);
                const isAdmin = ADMIN_UIDS.includes(user.uid);

                // Store current user globally for admin checks
                window.currentUser = user;

                loadSurvivorData();
            } else {
                logger.auth('üö´ User not authenticated - redirecting to login');
                // Redirect to main page for authentication
                window.location.href = '/';
            }
        });

        // Convert team names to ESPN abbreviations for helmet URLs
        function getTeamAbbreviation(teamName) {
            const teamAbbreviations = {
                'Arizona Cardinals': 'ARI',
                'Atlanta Falcons': 'ATL',
                'Baltimore Ravens': 'BAL',
                'Buffalo Bills': 'BUF',
                'Carolina Panthers': 'CAR',
                'Chicago Bears': 'CHI',
                'Cincinnati Bengals': 'CIN',
                'Cleveland Browns': 'CLE',
                'Dallas Cowboys': 'DAL',
                'Denver Broncos': 'DEN',
                'Detroit Lions': 'DET',
                'Green Bay Packers': 'GB',
                'Houston Texans': 'HOU',
                'Indianapolis Colts': 'IND',
                'Jacksonville Jaguars': 'JAX',
                'Kansas City Chiefs': 'KC',
                'Las Vegas Raiders': 'LV',
                'Los Angeles Chargers': 'LAC',
                'Los Angeles Rams': 'LAR',
                'Miami Dolphins': 'MIA',
                'Minnesota Vikings': 'MIN',
                'New England Patriots': 'NE',
                'New Orleans Saints': 'NO',
                'New York Giants': 'NYG',
                'New York Jets': 'NYJ',
                'Philadelphia Eagles': 'PHI',
                'Pittsburgh Steelers': 'PIT',
                'San Francisco 49ers': 'SF',
                'Seattle Seahawks': 'SEA',
                'Tampa Bay Buccaneers': 'TB',
                'Tennessee Titans': 'TEN',
                'Washington Commanders': 'WSH'
            };
            return teamAbbreviations[teamName] || 'NFL';
        }

        // Get current NFL week number
        function getCurrentWeekNumber() {
            const seasonStart = new Date('2025-09-04'); // Week 1 starts Sept 4, 2025
            const now = new Date();
            const daysSinceStart = Math.floor((now - seasonStart) / (1000 * 60 * 60 * 24));
            const weeksSinceStart = Math.floor(daysSinceStart / 7);
            return Math.max(1, Math.min(18, weeksSinceStart + 1));
        }

        async function loadBibleData(weekNumber) {
            logger.auth(`üîç Loading Week ${weekNumber} bible data from Firestore...`);

            try {
                const gamesPath = `artifacts/nerdfootball/public/data/nerdfootball_games/${weekNumber}`;
                const gamesRef = window.doc(window.db, gamesPath);
                const gamesSnap = await window.getDoc(gamesRef);

                if (!gamesSnap.exists()) {
                    logger.warn('AUTH', `No games found for Week ${weekNumber} in Firestore`);
                    return null;
                }

                const bibleData = gamesSnap.data();
                logger.auth(`‚úÖ Loaded Week ${weekNumber} bible data:`, Object.keys(bibleData).filter(k => k !== '_metadata').length, 'games');

                return bibleData;
            } catch (error) {
                logger.error('AUTH', `‚ùå Error loading Week ${weekNumber} bible data from Firestore:`, error);
                return null;
            }
        }

        async function loadCurrentWeekPicks() {
            const currentWeek = getCurrentWeekNumber();
            logger.auth(`üèà Loading current week (${currentWeek}) survivor picks for alive players...`);

            try {
                // Check if current week has started by loading bible data
                const bibleData = await loadBibleData(currentWeek);
                let weekHasStarted = false;

                if (bibleData) {
                    const games = Object.values(bibleData).filter(g => g && typeof g === 'object');
                    weekHasStarted = games.some(game =>
                        game.status === 'in_progress' ||
                        game.status === 'final' ||
                        game.status === 'FINAL' ||
                        game.started === true
                    );
                    logger.auth(`üèà Current week ${currentWeek} has ${weekHasStarted ? 'STARTED ‚úÖ' : 'NOT STARTED üîí'}`);
                } else {
                    logger.warn('AUTH', `‚ö†Ô∏è No bible data for Week ${currentWeek}`);
                    return { weekHasStarted: false, picks: {} };
                }

                const currentWeekPicks = {};

                // Only load picks if week has started
                logger.auth(`üéØ weekHasStarted = ${weekHasStarted}, currentWeek = ${currentWeek}`);
                if (weekHasStarted) {
                    logger.auth(`üéØ Loading currentWeek picks for alive survivors...`);

                    // Get alive survivor UIDs
                    const aliveUIDs = survivorsData
                        .filter(s => s.status === 'ALIVE')
                        .map(s => s.userId);

                    // Load picks for each alive survivor
                    const pickLoadPromises = aliveUIDs.map(async (userId) => {
                        try {
                            const userPicksPath = `artifacts/nerdfootball/public/data/nerdSurvivor_picks/${userId}`;
                            logger.auth(`  üîç Loading picks for ${userId} from: ${userPicksPath}`);
                            const userPicksRef = window.doc(window.db, userPicksPath);
                            const userPicksSnap = await window.getDoc(userPicksRef);

                            if (userPicksSnap.exists()) {
                                const userData = userPicksSnap.data();

                                // Debug: show picks structure
                                logger.auth(`  üìã ${userId} picks object:`, userData.picks);

                                // Picks are stored under userData.picks object, field is "team"
                                const weekKey = currentWeek.toString();
                                if (userData.picks && userData.picks[weekKey] && userData.picks[weekKey].team) {
                                    currentWeekPicks[userId] = userData.picks[weekKey].team;
                                    logger.auth(`  ‚úÖ ${userId}: Week ${currentWeek} pick = ${userData.picks[weekKey].team}`);
                                } else {
                                    logger.auth(`  ‚ö†Ô∏è ${userId}: No pick found`);
                                }
                            } else {
                                logger.auth(`  ‚ö†Ô∏è ${userId}: No survivor picks document found`);
                            }
                        } catch (error) {
                            logger.warn('AUTH', `  ‚ùå Error loading picks for ${userId}:`, error);
                        }
                    });

                    await Promise.all(pickLoadPromises);
                    logger.auth(`‚úÖ Loaded ${Object.keys(currentWeekPicks).length} current week survivor picks`);
                } else {
                    logger.auth(`üîí Week ${currentWeek} hasn't started - not showing picks yet`);
                }

                return { weekHasStarted, picks: currentWeekPicks };

            } catch (error) {
                logger.error('AUTH', '‚ùå Error loading current week picks:', error);
                return { weekHasStarted: false, picks: {} };
            }
        }


        async function processSurvivorData(result) {
            const survivorData = result.data;
            const currentWeek = getCurrentWeekNumber();

            // Process survivor data for display
            survivorsData = [];

            // Add alive survivors
            survivorData.alive.forEach(survivor => {
                const week1Pick = survivor.week1Pick || null;
                const allWinningPicks = survivor.allWinningPicks || [];

                // Create helmet display for winning picks
                let winningPicksDisplay = 'üö´ No Picks';
                if (allWinningPicks.length > 0) {
                    winningPicksDisplay = allWinningPicks.map(pick =>
                        `<img src="${pick.helmetUrl}" alt="${pick.team}" style="width:32px;height:32px;display:inline-block;margin:1px;" title="Week ${pick.week}: ${pick.team}">`
                    ).join(' ');
                } else if (week1Pick) {
                    winningPicksDisplay = week1Pick; // Fallback to text if no helmet data
                }

                survivorsData.push({
                    userId: survivor.userId,
                    name: survivor.displayName || survivor.name || 'Unknown Survivor',
                    email: survivor.email || '',
                    week1Pick: week1Pick,
                    allWinningPicks: winningPicksDisplay,
                    status: 'ALIVE',
                    temperature: allWinningPicks.length > 0 ? 'üî• Warming' : '‚ùÑÔ∏è No Pick',
                    isEliminated: false
                });
            });

            // Add eliminated survivors
            survivorData.eliminated.forEach(survivor => {
                const week1Pick = survivor.week1Pick || null;
                const allWinningPicks = survivor.allWinningPicks || [];

                // Create helmet display for winning picks (for eliminated survivors too)
                let winningPicksDisplay = 'üö´ No Picks';
                if (allWinningPicks.length > 0) {
                    winningPicksDisplay = allWinningPicks.map(pick =>
                        `<img src="${pick.helmetUrl}" alt="${pick.team}" style="width:32px;height:32px;display:inline-block;margin:1px;" title="Week ${pick.week}: ${pick.team}">`
                    ).join(' ');
                } else if (week1Pick) {
                    winningPicksDisplay = week1Pick; // Fallback to text if no helmet data
                }

                survivorsData.push({
                    userId: survivor.userId,
                    name: survivor.displayName || survivor.name || 'Unknown Survivor',
                    email: survivor.email || '',
                    week1Pick: week1Pick,
                    allWinningPicks: winningPicksDisplay,
                    status: `ELIMINATED (Week ${survivor.eliminatedWeek})`,
                    temperature: 'üßä Frozen Solid',
                    isEliminated: true,
                    eliminatedBy: survivor.eliminatedBy,
                    eliminatedWeek: survivor.eliminatedWeek
                });
            });

            // Add non-participating members
            survivorData.nonParticipating.forEach(member => {
                survivorsData.push({
                    userId: member.userId,
                    name: member.displayName || member.name || 'Unknown',
                    email: member.email || '',
                    week1Pick: null,
                    allWinningPicks: 'üö´ No Picks',
                    status: 'NOT_PARTICIPATING',
                    temperature: 'üå°Ô∏è Not Entered',
                    isEliminated: false
                });
            });

            // Check for current week picks if any games have started (Masters Audit logic)
            logger.auth('üîç About to call loadCurrentWeekPicks()...');
            try {
                const { weekHasStarted, picks: currentWeekPicks } = await loadCurrentWeekPicks();
                logger.auth('‚úÖ loadCurrentWeekPicks() completed:', { weekHasStarted, pickCount: Object.keys(currentWeekPicks).length });

                // Add current week picks to alive survivors
                if (weekHasStarted && Object.keys(currentWeekPicks).length > 0) {
                    survivorsData.forEach(survivor => {
                        if (survivor.status === 'ALIVE' && currentWeekPicks[survivor.userId]) {
                            survivor.currentWeekPick = {
                                team: currentWeekPicks[survivor.userId],
                                week: currentWeek
                            };
                            logger.auth(`‚úÖ Added Week ${currentWeek} pick for ${survivor.name}: ${currentWeekPicks[survivor.userId]}`);
                        }
                    });
                }
            } catch (error) {
                logger.error('AUTH', '‚ùå Error in loadCurrentWeekPicks():', error);
            }

            displaySurvivorData();
        }

        async function loadSurvivorData() {
            try {
                logger.auth('üßä Loading fresh survival chamber data...');
                const cacheBuster = Date.now();
                const response = await fetch(`https://getsurvivorpooldata-np7uealtnq-uc.a.run.app?t=${cacheBuster}`);

                if (!response.ok) {
                    throw new Error(`Firebase Function error: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();

                if (!result.success) {
                    throw new Error(result.error || 'Failed to load survivor data');
                }

                logger.auth('‚úÖ Survivor data loaded from Firebase Function:', result.data.summary);

                // Process data and display
                await processSurvivorData(result);

            } catch (error) {
                logger.error('AUTH', '‚ùå Error loading survivor data:', error);
                showError(error.message);
            }
        }

        function displaySurvivorData() {
            const aliveSurvivors = survivorsData.filter(s => s.status === 'ALIVE');
            const eliminatedSurvivors = survivorsData.filter(s => s.isEliminated);
            const nonParticipating = survivorsData.filter(s => s.status === 'NOT_PARTICIPATING');

            // Update stats
            document.getElementById('alive-count').textContent = aliveSurvivors.length;
            document.getElementById('eliminated-count').textContent = eliminatedSurvivors.length;
            document.getElementById('total-count').textContent = survivorsData.length;

            // Sort: alive first (alphabetical), then eliminated (by elimination week), then non-participating
            const sortedSurvivors = [
                ...aliveSurvivors.sort((a, b) => a.name.localeCompare(b.name)),
                ...eliminatedSurvivors.sort((a, b) => {
                    // Sort by elimination week, then by name
                    if (a.eliminatedWeek !== b.eliminatedWeek) {
                        return a.eliminatedWeek - b.eliminatedWeek;
                    }
                    return a.name.localeCompare(b.name);
                }),
                ...nonParticipating.sort((a, b) => a.name.localeCompare(b.name))
            ];

            // Generate table rows
            const tbody = document.getElementById('survivor-body');
            const tableRows = sortedSurvivors.map(survivor => {
                let statusClass, statusText, statusIcon;

                if (survivor.status === 'ALIVE') {
                    statusClass = 'alive';
                    statusText = 'üêâ SHAOLIN SURVIVOR';
                    statusIcon = 'üî•';
                } else if (survivor.isEliminated) {
                    statusClass = 'eliminated';
                    statusText = `‚ò†Ô∏è FALLEN WARRIOR`;
                    statusIcon = 'üó°Ô∏è';
                } else {
                    statusClass = 'eliminated';
                    statusText = 'üëª GHOST';
                    statusIcon = 'üå´Ô∏è';
                }

                // Show ONLY past winning picks (allWinningPicks already includes current week if it's won)
                // Do NOT add current week separately to avoid duplicates
                let picksDisplay = survivor.allWinningPicks || 'üö´ No Pick';
                const eliminationInfo = survivor.isEliminated ?
                    ` (Week ${survivor.eliminatedWeek}: ${survivor.eliminatedBy})` : '';

                return `
                    <tr class="border-b border-gray-600 ${statusClass}">
                        <td class="px-4 py-3 font-medium">${survivor.name}</td>
                        <td class="px-4 py-3">${picksDisplay}</td>
                        <td class="px-4 py-3">${statusText}${eliminationInfo}</td>
                        <td class="px-4 py-3">${statusIcon} ${survivor.temperature}</td>
                    </tr>
                `;
            }).join('');

            tbody.innerHTML = tableRows;

            // Show current week picks if games have started
            displayCurrentWeekPicks();

            // Show results
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('stats').classList.remove('hidden');
            document.getElementById('survivor-table').classList.remove('hidden');

            logger.auth(`‚úÖ Chamber loaded: ${aliveSurvivors.length} alive, ${eliminatedSurvivors.length} eliminated, ${nonParticipating.length} not participating`);
        }

        function displayCurrentWeekPicks() {
            const currentWeek = getCurrentWeekNumber();

            // Debug logging
            const aliveCount = survivorsData.filter(s => s.status === 'ALIVE').length;
            const aliveWithPicksCount = survivorsData.filter(s => s.status === 'ALIVE' && s.currentWeekPick).length;
            logger.auth(`üìä Week ${currentWeek} display: ${aliveCount} alive, ${aliveWithPicksCount} with current picks`);

            const aliveWithCurrentPicks = survivorsData
                .filter(s => s.status === 'ALIVE' && s.currentWeekPick)
                .sort((a, b) => a.name.localeCompare(b.name));

            const currentPicksContainer = document.getElementById('current-week-picks');

            if (aliveWithCurrentPicks.length === 0) {
                logger.auth(`‚ùå No current week picks to display - hiding container`);
                currentPicksContainer.style.display = 'none';
                return;
            }

            const picksList = aliveWithCurrentPicks.map(survivor => {
                const helmetUrl = `https://a.espncdn.com/i/teamlogos/nfl/500/${getTeamAbbreviation(survivor.currentWeekPick.team)}.png`;
                return `
                    <div class="flex items-center space-x-3 p-3 rounded-lg border border-yellow-500" style="background: rgba(0, 0, 0, 0.6);">
                        <img src="${helmetUrl}" alt="${survivor.currentWeekPick.team}" style="width:32px;height:32px;" />
                        <div>
                            <div class="text-yellow-300 font-semibold">${survivor.name}</div>
                            <div class="text-yellow-500 text-sm">${survivor.currentWeekPick.team}</div>
                        </div>
                    </div>
                `;
            }).join('');

            document.getElementById('current-picks-list').innerHTML = picksList;
            document.getElementById('current-picks-count').textContent = aliveWithCurrentPicks.length;
            document.getElementById('current-week-number').textContent = currentWeek;
            currentPicksContainer.style.display = 'block';
        }

        function showError(message) {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').classList.remove('hidden');
            document.getElementById('error-message').textContent = message;
        }

        // No need for DOMContentLoaded since authentication will trigger loadSurvivorData

        // Header menu functionality (from nerd-universe.html)
        document.getElementById('menu-btn').addEventListener('click', function() {
            const menu = document.getElementById('menu-panel');
            menu.classList.toggle('hidden');
        });

        // Close menus when clicking outside
        document.addEventListener('click', function(event) {
            const menuBtn = document.getElementById('menu-btn');
            const menuPanel = document.getElementById('menu-panel');

            // Close hamburger menu
            if (!menuBtn.contains(event.target) && !menuPanel.contains(event.target)) {
                menuPanel.classList.add('hidden');
            }
        });

        // Global logout function for header buttons
        window.handleLogout = async function() {
            if (confirm('Are you sure you want to logout?')) {
                try {
                    // Close hamburger menu if open
                    const menuPanel = document.getElementById('menu-panel');
                    menuPanel.classList.add('hidden');

                    await window.signOut(auth);
                    window.location.href = './login.html';
                } catch (error) {
                    logger.error('AUTH', 'Logout error:', error);
                    alert('Error logging out. Please try again.');
                }
            }
        };


        // Make loadSurvivorData globally accessible
        window.loadSurvivorData = loadSurvivorData;
    </script>

    <!-- Cosmic Background JavaScript -->
    <script>
        // Deep space cosmic background
        const canvas = document.getElementById('matrix-bg');
        const ctx = canvas.getContext('2d');

        console.log('üåå COSMIC: Canvas element:', canvas);
        console.log('üåå COSMIC: Context:', ctx);
        console.log('üåå COSMIC: Canvas size:', canvas.width, 'x', canvas.height);

        // Star configuration - MUST be declared before setCanvasSize()
        const stars = [];
        const shootingStars = [];
        const backgroundStars = 600; // Distant stars

        // Easter egg state
        let easterEggStar = null;
        let spaceship = null;
        let alien = null;
        let easterEggActivated = false;

        // Constellation data (eastern sky) - relative positions normalized 0-1
        const constellations = {
            orion: {
                name: 'Orion',
                stars: [
                    {x: 0.25, y: 0.3, size: 5, brightness: 1.0, name: 'Betelgeuse', color: 'rgb(255, 150, 100)'}, // Red supergiant
                    {x: 0.25, y: 0.55, size: 4.5, brightness: 1.0, name: 'Rigel', color: 'rgb(180, 200, 255)'}, // Blue-white
                    {x: 0.23, y: 0.42, size: 2.5, brightness: 0.9, name: 'Bellatrix', color: 'rgb(200, 220, 255)'},
                    {x: 0.27, y: 0.42, size: 2.5, brightness: 0.9, name: 'Mintaka', color: 'rgb(200, 220, 255)'},
                    {x: 0.25, y: 0.43, size: 2.5, brightness: 0.9, name: 'Alnilam', color: 'rgb(200, 220, 255)'},
                    {x: 0.23, y: 0.44, size: 2.5, brightness: 0.9, name: 'Alnitak', color: 'rgb(200, 220, 255)'},
                    {x: 0.27, y: 0.52, size: 2, brightness: 0.8, name: 'Saiph', color: 'rgb(200, 220, 255)'}
                ]
            },
            taurus: {
                name: 'Taurus',
                stars: [
                    {x: 0.18, y: 0.35, size: 4, brightness: 1.0, name: 'Aldebaran', color: 'rgb(255, 180, 120)'}, // Red giant
                    {x: 0.15, y: 0.25, size: 1.5, brightness: 0.7, name: 'Pleiades1', color: 'rgb(200, 220, 255)'},
                    {x: 0.14, y: 0.24, size: 1.5, brightness: 0.7, name: 'Pleiades2', color: 'rgb(200, 220, 255)'},
                    {x: 0.16, y: 0.26, size: 1.5, brightness: 0.7, name: 'Pleiades3', color: 'rgb(200, 220, 255)'},
                    {x: 0.15, y: 0.27, size: 1.5, brightness: 0.7, name: 'Pleiades4', color: 'rgb(200, 220, 255)'}
                ]
            },
            gemini: {
                name: 'Gemini',
                stars: [
                    {x: 0.35, y: 0.28, size: 3.5, brightness: 1.0, name: 'Castor', color: 'rgb(220, 230, 255)'},
                    {x: 0.33, y: 0.32, size: 3.5, brightness: 1.0, name: 'Pollux', color: 'rgb(255, 200, 150)'}
                ]
            },
            canisMajor: {
                name: 'Canis Major',
                stars: [
                    {x: 0.28, y: 0.65, size: 6, brightness: 1.0, name: 'Sirius', color: 'rgb(200, 220, 255)'}, // Brightest star
                    {x: 0.30, y: 0.70, size: 2, brightness: 0.8, name: 'Adhara', color: 'rgb(200, 220, 255)'}
                ]
            },
            canisMinor: {
                name: 'Canis Minor',
                stars: [
                    {x: 0.32, y: 0.48, size: 3.5, brightness: 1.0, name: 'Procyon', color: 'rgb(240, 245, 255)'}
                ]
            },
            leo: {
                name: 'Leo',
                stars: [
                    {x: 0.50, y: 0.45, size: 4, brightness: 1.0, name: 'Regulus', color: 'rgb(200, 220, 255)'},
                    {x: 0.55, y: 0.35, size: 3, brightness: 0.9, name: 'Denebola', color: 'rgb(220, 230, 255)'},
                    {x: 0.48, y: 0.38, size: 2.5, brightness: 0.8, name: 'Algieba', color: 'rgb(255, 200, 150)'}
                ]
            },
            virgo: {
                name: 'Virgo',
                stars: [
                    {x: 0.62, y: 0.52, size: 4, brightness: 1.0, name: 'Spica', color: 'rgb(180, 200, 255)'}
                ]
            },
            bootes: {
                name: 'Bo√∂tes',
                stars: [
                    {x: 0.68, y: 0.38, size: 4.5, brightness: 1.0, name: 'Arcturus', color: 'rgb(255, 180, 120)'} // Orange giant
                ]
            },
            perseus: {
                name: 'Perseus',
                stars: [
                    {x: 0.12, y: 0.20, size: 3, brightness: 0.9, name: 'Mirfak', color: 'rgb(240, 245, 255)'},
                    {x: 0.10, y: 0.25, size: 2.5, brightness: 0.8, name: 'Algol', color: 'rgb(200, 220, 255)'}
                ]
            },
            auriga: {
                name: 'Auriga',
                stars: [
                    {x: 0.20, y: 0.15, size: 4, brightness: 1.0, name: 'Capella', color: 'rgb(255, 240, 200)'} // Yellow
                ]
            }
        };

        function initializeStars() {
            stars.length = 0;

            // Add constellation stars first (foreground - close)
            Object.values(constellations).forEach(constellation => {
                constellation.stars.forEach(starData => {
                    stars.push({
                        x: starData.x * canvas.width,
                        y: starData.y * canvas.height,
                        size: starData.size,
                        color: starData.color,
                        twinkleSpeed: 0.02,
                        twinklePhase: Math.random() * Math.PI * 2,
                        brightness: starData.brightness,
                        depth: 1.0, // Close (constellation stars)
                        isConstellation: true,
                        name: starData.name
                    });
                });
            });

            // Add random background stars (distant - smaller)
            for (let i = 0; i < backgroundStars; i++) {
                const depth = Math.random(); // 0 = far, 1 = close
                const baseSize = 0.5 + depth * 2; // Far stars: 0.5-1px, Close: 1.5-2.5px
                const starColor = ['rgb(255, 255, 255)', 'rgb(200, 220, 255)', 'rgb(255, 255, 200)', 'rgb(255, 200, 200)'][Math.floor(Math.random() * 4)];

                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    size: baseSize,
                    color: starColor,
                    twinkleSpeed: Math.random() * 0.05 + 0.01,
                    twinklePhase: Math.random() * Math.PI * 2,
                    brightness: 0.3 + depth * 0.5, // Far stars dimmer
                    depth: depth,
                    isConstellation: false
                });
            }

            console.log('üåå COSMIC: Initialized', stars.length, 'stars (', Object.values(constellations).reduce((sum, c) => sum + c.stars.length, 0), 'constellation stars )');

            // Pick a random constellation star as the easter egg (make it slightly more special)
            const constellationStars = stars.filter(s => s.isConstellation);
            easterEggStar = constellationStars[Math.floor(Math.random() * constellationStars.length)];
            easterEggStar.isEasterEgg = true;
            console.log('üéÅ COSMIC: Easter egg star is', easterEggStar.name, 'at', easterEggStar.x.toFixed(0), ',', easterEggStar.y.toFixed(0));
        }

        // Nebulae configuration (colorful galactic clouds)
        const nebulae = [];

        function initializeNebulae() {
            nebulae.length = 0;
            const nebulaCount = 5;
            const nebulaColors = [
                ['rgba(138, 43, 226, 0.15)', 'rgba(75, 0, 130, 0)'],      // Purple
                ['rgba(255, 20, 147, 0.12)', 'rgba(138, 43, 226, 0)'],    // Pink-Purple
                ['rgba(0, 100, 255, 0.1)', 'rgba(0, 50, 150, 0)'],        // Blue
                ['rgba(255, 100, 50, 0.08)', 'rgba(255, 50, 0, 0)'],      // Orange
                ['rgba(0, 255, 150, 0.06)', 'rgba(0, 100, 100, 0)']       // Cyan
            ];

            for (let i = 0; i < nebulaCount; i++) {
                const colors = nebulaColors[i % nebulaColors.length];
                nebulae.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 300 + 200,
                    colorStart: colors[0],
                    colorEnd: colors[1]
                });
            }
        }

        // Shooting stars
        function createShootingStar() {
            const startSide = Math.random();
            let x, y, velocityX, velocityY;

            if (startSide < 0.5) {
                // Start from top
                x = Math.random() * canvas.width;
                y = -10;
                velocityX = (Math.random() - 0.5) * 8;
                velocityY = Math.random() * 6 + 4;
            } else {
                // Start from right
                x = canvas.width + 10;
                y = Math.random() * canvas.height * 0.5;
                velocityX = -(Math.random() * 6 + 4);
                velocityY = Math.random() * 4 + 2;
            }

            shootingStars.push({
                x: x,
                y: y,
                velocityX: velocityX,
                velocityY: velocityY,
                length: Math.random() * 60 + 40,
                brightness: 1,
                fadeRate: Math.random() * 0.015 + 0.01
            });
        }

        // Create shooting stars randomly
        setInterval(() => {
            if (Math.random() < 0.3) {
                createShootingStar();
            }
        }, 2000);

        function drawCosmos() {
            // Deep black space background
            ctx.fillStyle = 'rgba(0, 0, 0, 1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw nebulae (colorful galactic clouds)
            nebulae.forEach(nebula => {
                const gradient = ctx.createRadialGradient(
                    nebula.x, nebula.y, 0,
                    nebula.x, nebula.y, nebula.radius
                );
                gradient.addColorStop(0, nebula.colorStart);
                gradient.addColorStop(1, nebula.colorEnd);

                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            });

            // Draw stars with realistic twinkling
            const time = Date.now() * 0.001;
            stars.forEach(star => {
                // Enhanced twinkling for easter egg star
                let twinkleBase, twinkleIntensity;
                if (star.isEasterEgg) {
                    // Easter egg: faster, more pronounced twinkling
                    twinkleBase = Math.sin(time * star.twinkleSpeed * 2 + star.twinklePhase);
                    twinkleIntensity = 0.8 + Math.abs(twinkleBase) * 0.2; // 0.8 to 1.0, always twinkling
                } else {
                    // Normal stars: realistic intermittent twinkling
                    twinkleBase = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
                    const shouldTwinkle = twinkleBase > 0.5;
                    twinkleIntensity = shouldTwinkle ?
                        0.7 + (twinkleBase - 0.5) * 0.6 : // Twinkle: 0.7 to 1.0
                        star.brightness; // Steady brightness
                }

                const actualSize = star.size * twinkleIntensity;

                ctx.beginPath();
                ctx.arc(star.x, star.y, actualSize, 0, Math.PI * 2);
                ctx.fillStyle = star.color;
                ctx.fill();

                // Add glow for larger stars (more prominent on constellation stars)
                if (star.size > 2) {
                    const glowSize = star.isConstellation ? actualSize * 5 : actualSize * 3;
                    const gradient = ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, glowSize
                    );
                    const glowAlpha = star.isConstellation ? 0.8 : 0.5;
                    const colorWithAlpha = star.color.replace('rgb', 'rgba').replace(')', `, ${glowAlpha * twinkleIntensity})`);
                    gradient.addColorStop(0, colorWithAlpha);
                    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(star.x - glowSize, star.y - glowSize,
                                glowSize * 2, glowSize * 2);
                }

                // Add very faint blue glow to easter egg star
                if (star.isEasterEgg) {
                    const easterGlowSize = actualSize * 8;
                    const easterGradient = ctx.createRadialGradient(
                        star.x, star.y, 0,
                        star.x, star.y, easterGlowSize
                    );
                    const blueGlowAlpha = 0.08 + Math.abs(twinkleBase) * 0.04; // Very faint: 0.08 to 0.12
                    easterGradient.addColorStop(0, `rgba(100, 150, 255, ${blueGlowAlpha})`);
                    easterGradient.addColorStop(0.5, `rgba(50, 100, 200, ${blueGlowAlpha * 0.5})`);
                    easterGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
                    ctx.fillStyle = easterGradient;
                    ctx.fillRect(star.x - easterGlowSize, star.y - easterGlowSize,
                                easterGlowSize * 2, easterGlowSize * 2);
                }
            });

            // Draw and update shooting stars
            for (let i = shootingStars.length - 1; i >= 0; i--) {
                const star = shootingStars[i];

                // Draw trail
                const gradient = ctx.createLinearGradient(
                    star.x, star.y,
                    star.x - star.velocityX * 2, star.y - star.velocityY * 2
                );
                gradient.addColorStop(0, `rgba(255, 255, 255, ${star.brightness})`);
                gradient.addColorStop(0.5, `rgba(200, 220, 255, ${star.brightness * 0.5})`);
                gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');

                ctx.strokeStyle = gradient;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(star.x, star.y);
                ctx.lineTo(star.x - star.velocityX * 5, star.y - star.velocityY * 5);
                ctx.stroke();

                // Update position
                star.x += star.velocityX;
                star.y += star.velocityY;
                star.brightness -= star.fadeRate;

                // Remove if faded or off screen
                if (star.brightness <= 0 ||
                    star.x < -50 || star.x > canvas.width + 50 ||
                    star.y < -50 || star.y > canvas.height + 50) {
                    shootingStars.splice(i, 1);
                }
            }

            // Add Milky Way effect (dense star cluster)
            if (Math.random() < 0.1) {
                const milkyWayY = canvas.height * 0.4 + Math.sin(time * 0.1) * 50;
                ctx.fillStyle = 'rgba(200, 200, 255, 0.02)';
                ctx.fillRect(0, milkyWayY - 100, canvas.width, 200);
            }

            // Draw easter egg elements
            drawSpaceship();
            drawAlien();

            requestAnimationFrame(drawCosmos);
        }

        // Easter egg click detection
        canvas.addEventListener('click', (event) => {
            if (easterEggActivated || !easterEggStar) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Check if click is near easter egg star
            const distance = Math.sqrt(Math.pow(clickX - easterEggStar.x, 2) + Math.pow(clickY - easterEggStar.y, 2));
            if (distance < 20) {
                console.log('üéÅ EASTER EGG ACTIVATED! üõ∏üëΩ');
                easterEggActivated = true;

                // Create spaceship
                spaceship = {
                    x: canvas.width / 2,
                    y: -100,
                    width: 80,
                    height: 40,
                    velocityY: 2,
                    dropping: true
                };

                // Alien will be created when spaceship lands
                setTimeout(() => {
                    alien = {
                        x: spaceship.x,
                        y: canvas.height - 60,
                        width: 30,
                        height: 50,
                        velocityX: 2,
                        direction: 1,
                        walkCycle: 0
                    };
                    spaceship.dropping = false;
                    spaceship.leaving = true;
                }, 3000); // Spaceship drops off alien after 3 seconds
            }
        });

        // Draw spaceship
        function drawSpaceship() {
            if (!spaceship) return;

            if (spaceship.dropping) {
                // Descend
                spaceship.y += spaceship.velocityY;
                if (spaceship.y > canvas.height - 150) {
                    spaceship.velocityY = 0;
                }
            } else if (spaceship.leaving) {
                // Ascend
                spaceship.y -= 3;
                if (spaceship.y < -100) {
                    spaceship = null;
                    return;
                }
            }

            // Draw UFO shape
            ctx.save();
            ctx.translate(spaceship.x, spaceship.y);

            // Dome
            ctx.beginPath();
            ctx.arc(0, -10, 20, 0, Math.PI, true);
            ctx.fillStyle = 'rgba(100, 255, 200, 0.6)';
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.ellipse(0, 0, 40, 15, 0, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(150, 150, 150, 0.9)';
            ctx.fill();
            ctx.strokeStyle = 'rgba(100, 255, 200, 0.8)';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Lights
            const time = Date.now() * 0.01;
            for (let i = -1; i <= 1; i++) {
                const lightAlpha = (Math.sin(time + i) + 1) / 2;
                ctx.beginPath();
                ctx.arc(i * 15, 5, 3, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 0, ${lightAlpha})`;
                ctx.fill();
            }

            // Beam when dropping
            if (spaceship.dropping && spaceship.y > 50) {
                ctx.beginPath();
                ctx.moveTo(-30, 15);
                ctx.lineTo(-15, canvas.height - spaceship.y);
                ctx.lineTo(15, canvas.height - spaceship.y);
                ctx.lineTo(30, 15);
                ctx.closePath();
                ctx.fillStyle = 'rgba(100, 255, 200, 0.2)';
                ctx.fill();
            }

            ctx.restore();
        }

        // Draw alien
        function drawAlien() {
            if (!alien) return;

            // Walk across screen
            alien.x += alien.velocityX * alien.direction;
            alien.walkCycle += 0.1;

            // Turn around at edges
            if (alien.x > canvas.width + 50) {
                alien.direction = -1;
                alien.x = canvas.width + 40;
            } else if (alien.x < -50) {
                alien.direction = 1;
                alien.x = -40;
            }

            ctx.save();
            ctx.translate(alien.x, alien.y);
            if (alien.direction === -1) ctx.scale(-1, 1);

            // Head
            ctx.beginPath();
            ctx.arc(0, -30, 15, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(100, 255, 150, 0.8)';
            ctx.fill();

            // Eyes
            ctx.beginPath();
            ctx.arc(-5, -32, 4, 0, Math.PI * 2);
            ctx.arc(5, -32, 4, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fill();

            // Body
            ctx.beginPath();
            ctx.rect(-8, -15, 16, 25);
            ctx.fillStyle = 'rgba(100, 255, 150, 0.7)';
            ctx.fill();

            // Arms
            const armSwing = Math.sin(alien.walkCycle) * 5;
            ctx.beginPath();
            ctx.moveTo(-8, -10);
            ctx.lineTo(-15, 0 + armSwing);
            ctx.strokeStyle = 'rgba(100, 255, 150, 0.7)';
            ctx.lineWidth = 3;
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(8, -10);
            ctx.lineTo(15, 0 - armSwing);
            ctx.stroke();

            // Legs (walking animation)
            const legSwing = Math.sin(alien.walkCycle) * 8;
            ctx.beginPath();
            ctx.moveTo(-4, 10);
            ctx.lineTo(-4 + legSwing, 25);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(4, 10);
            ctx.lineTo(4 - legSwing, 25);
            ctx.stroke();

            ctx.restore();
        }

        // Set canvas size function
        function setCanvasSize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            console.log('üåå COSMIC: Resized canvas to', canvas.width, 'x', canvas.height);
            initializeStars();
            initializeNebulae();
        }

        // Initialize everything
        setCanvasSize();
        window.addEventListener('resize', setCanvasSize);

        // Start animation
        drawCosmos();

        // ============================================
        // SPACE SHOOTER GAME LOGIC
        // ============================================

        const gameCanvas = document.getElementById('game-canvas');
        const gameCtx = gameCanvas.getContext('2d');
        const gameZone = document.getElementById('game-zone');
        let gameActive = false;
        let gameScore = 0;
        let gameLives = 3;
        let gameLevel = 1;

        // Responsive canvas dimensions
        function setGameCanvasSize() {
            const maxWidth = Math.min(800, window.innerWidth - 40);
            const maxHeight = Math.min(600, window.innerHeight * 0.6);
            gameCanvas.width = maxWidth;
            gameCanvas.height = maxHeight;

            // Reset player position on resize
            if (player) {
                player.x = gameCanvas.width / 2;
                player.y = gameCanvas.height - 80;
            }
        }

        setGameCanvasSize();
        window.addEventListener('resize', setGameCanvasSize);

        // Player ship
        const player = {
            x: gameCanvas.width / 2,
            y: gameCanvas.height - 80,
            width: 40,
            height: 50,
            speed: 8,
            moveLeft: false,
            moveRight: false
        };

        // Bullets
        const bullets = [];
        const bulletSpeed = 10;
        const bulletWidth = 4;
        const bulletHeight = 15;

        // Enemies
        const enemies = [];
        const enemySpeed = 2;
        let enemySpawnRate = 60; // frames between spawns

        // Glassmorphism button and scroll detection
        const gameButtonContainer = document.getElementById('game-button-container');
        const gameButton = document.getElementById('game-button');
        let gameZoneActivated = false;
        let buttonShown = false;

        console.log('üéÆ GAME: Button container found:', !!gameButtonContainer);
        console.log('üéÆ GAME: Button found:', !!gameButton);
        console.log('üéÆ GAME: Game zone found:', !!gameZone);

        window.addEventListener('scroll', () => {
            const scrollY = window.scrollY || window.pageYOffset;
            const tableElement = document.getElementById('survivor-table');

            // Skip if table isn't loaded yet
            if (!tableElement) {
                console.log('üéÆ GAME: Table not found yet');
                return;
            }

            // Check if table is visible (not hidden)
            const isTableVisible = !tableElement.classList.contains('hidden');

            if (!isTableVisible) {
                console.log('üéÆ GAME: Table is hidden, skipping scroll check');
                return;
            }

            const tableRect = tableElement.getBoundingClientRect();
            const tableBottom = tableRect.bottom;

            console.log('üéÆ GAME: Scroll check - tableBottom:', tableBottom, 'buttonShown:', buttonShown);

            // Show button when table scrolls out of view
            if (tableBottom < 0 && !buttonShown) {
                console.log('üéÆ GAME: Showing button - container exists:', !!gameButtonContainer);
                if (gameButtonContainer) {
                    gameButtonContainer.style.opacity = '1';
                    console.log('üéÆ GAME: Set opacity to 1, current opacity:', gameButtonContainer.style.opacity);
                }
                buttonShown = true;
                console.log('üéÆ GAME: Button appeared');
            } else if (tableBottom > 0 && buttonShown) {
                if (gameButtonContainer) {
                    gameButtonContainer.style.opacity = '0';
                }
                buttonShown = false;
                console.log('üéÆ GAME: Button hidden');
            }

            // Check if we're in the game zone (for returning from game)
            const gameZoneRect = gameZone.getBoundingClientRect();
            if (gameZoneRect.top < window.innerHeight && gameZoneRect.bottom > 0) {
                if (!gameZoneActivated) {
                    gameZone.style.opacity = '1';
                    gameZoneActivated = true;
                }
            } else if (gameZoneActivated && gameZoneRect.top > window.innerHeight) {
                gameZone.style.opacity = '0';
                gameZoneActivated = false;
                if (gameActive) {
                    pauseGame();
                }
            }
        });

        // Hyperspace star animation
        const hyperspaceCanvas = document.getElementById('hyperspace-canvas');
        const hyperspaceCtx = hyperspaceCanvas.getContext('2d');
        hyperspaceCanvas.width = window.innerWidth;
        hyperspaceCanvas.height = window.innerHeight;

        const hyperspaceStars = [];
        let hyperspaceActive = false;

        function createHyperspaceStars() {
            hyperspaceStars.length = 0;
            for (let i = 0; i < 200; i++) {
                hyperspaceStars.push({
                    x: Math.random() * hyperspaceCanvas.width,
                    y: Math.random() * hyperspaceCanvas.height,
                    z: Math.random() * hyperspaceCanvas.width,
                    speed: 0
                });
            }
        }

        function drawHyperspace() {
            if (!hyperspaceActive) return;

            hyperspaceCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            hyperspaceCtx.fillRect(0, 0, hyperspaceCanvas.width, hyperspaceCanvas.height);

            hyperspaceStars.forEach(star => {
                star.speed += 2;
                star.z -= star.speed;

                if (star.z <= 0) {
                    star.z = hyperspaceCanvas.width;
                    star.speed = 0;
                }

                const x = (star.x - hyperspaceCanvas.width / 2) * (hyperspaceCanvas.width / star.z) + hyperspaceCanvas.width / 2;
                const y = (star.y - hyperspaceCanvas.height / 2) * (hyperspaceCanvas.width / star.z) + hyperspaceCanvas.height / 2;
                const size = (1 - star.z / hyperspaceCanvas.width) * 3;

                hyperspaceCtx.fillStyle = '#ffffff';
                hyperspaceCtx.beginPath();
                hyperspaceCtx.arc(x, y, size, 0, Math.PI * 2);
                hyperspaceCtx.fill();

                // Star trail
                const trailLength = star.speed * 2;
                hyperspaceCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                hyperspaceCtx.lineWidth = size;
                hyperspaceCtx.beginPath();
                hyperspaceCtx.moveTo(x, y);
                hyperspaceCtx.lineTo(x, y + trailLength);
                hyperspaceCtx.stroke();
            });

            requestAnimationFrame(drawHyperspace);
        }

        // Button click - hyperspace transition to game
        if (gameButton) {
            gameButton.addEventListener('click', () => {
                console.log('üéÆ GAME: Button clicked - activating hyperspace jump');
                console.log('üéÆ GAME: gameZone exists:', !!gameZone);

                if (!gameZone) {
                    console.error('üéÆ GAME: Game zone element not found!');
                    return;
                }

                // Hide button
                gameButtonContainer.style.opacity = '0';
                buttonShown = false;

                // Start hyperspace animation
                console.log('üéÆ GAME: Starting hyperspace animation');
                createHyperspaceStars();
                hyperspaceCanvas.style.opacity = '1';
                hyperspaceActive = true;
                drawHyperspace();

                // Stop hyperspace and fade in game after 2 seconds
                setTimeout(() => {
                    console.log('üéÆ GAME: Hyperspace complete, fading in game');
                    hyperspaceActive = false;
                    hyperspaceCanvas.style.opacity = '0';

                    // Fade in game zone
                    gameZone.style.opacity = '1';
                    gameZone.style.pointerEvents = 'auto';
                    gameZoneActivated = true;

                    console.log('üéÆ GAME: Calling startGame()');
                    if (!gameActive) {
                        startGame();
                    }
                }, 2000);
            });
        } else {
            console.error('üéÆ GAME: Button element not found - click handler not attached!');
        }

        // Keyboard controls
        const keys = {};
        window.addEventListener('keydown', (e) => {
            if (!gameActive) return;

            keys[e.key] = true;

            if (e.key === 'ArrowLeft') {
                player.moveLeft = true;
                e.preventDefault();
            }
            if (e.key === 'ArrowRight') {
                player.moveRight = true;
                e.preventDefault();
            }
            if (e.key === ' ') {
                shootBullet();
                e.preventDefault();
            }
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;

            if (e.key === 'ArrowLeft') player.moveLeft = false;
            if (e.key === 'ArrowRight') player.moveRight = false;
        });

        // Mobile touch controls
        const btnLeft = document.getElementById('btn-left');
        const btnRight = document.getElementById('btn-right');
        const btnShoot = document.getElementById('btn-shoot');

        if (btnLeft) {
            btnLeft.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) player.moveLeft = true;
            });
            btnLeft.addEventListener('touchend', (e) => {
                e.preventDefault();
                player.moveLeft = false;
            });
            btnLeft.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (gameActive) player.moveLeft = true;
            });
            btnLeft.addEventListener('mouseup', (e) => {
                e.preventDefault();
                player.moveLeft = false;
            });
        }

        if (btnRight) {
            btnRight.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) player.moveRight = true;
            });
            btnRight.addEventListener('touchend', (e) => {
                e.preventDefault();
                player.moveRight = false;
            });
            btnRight.addEventListener('mousedown', (e) => {
                e.preventDefault();
                if (gameActive) player.moveRight = true;
            });
            btnRight.addEventListener('mouseup', (e) => {
                e.preventDefault();
                player.moveRight = false;
            });
        }

        if (btnShoot) {
            btnShoot.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (gameActive) shootBullet();
            });
            btnShoot.addEventListener('click', (e) => {
                e.preventDefault();
                if (gameActive) shootBullet();
            });
        }

        function startGame() {
            console.log('üéÆ GAME: startGame() called');
            console.log('üéÆ GAME: gameCanvas exists:', !!gameCanvas);
            console.log('üéÆ GAME: gameCanvas dimensions:', gameCanvas.width, 'x', gameCanvas.height);
            console.log('üéÆ GAME: gameZone opacity:', gameZone.style.opacity);

            gameActive = true;
            gameScore = 0;
            gameLives = 3;
            gameLevel = 1;
            bullets.length = 0;
            enemies.length = 0;
            player.x = gameCanvas.width / 2;
            updateGameUI();
            document.getElementById('game-over').classList.add('hidden');
            console.log('üéÆ GAME: Started - gameActive:', gameActive);
            gameLoop();
        }

        function pauseGame() {
            gameActive = false;
            console.log('‚è∏Ô∏è GAME: Paused');
        }

        function endGame() {
            gameActive = false;
            document.getElementById('final-score').textContent = gameScore;
            document.getElementById('game-over').classList.remove('hidden');
            console.log('üíÄ GAME: Over - Score:', gameScore);
        }

        document.getElementById('restart-game').addEventListener('click', startGame);

        function updateGameUI() {
            document.getElementById('game-score').textContent = gameScore;
            document.getElementById('game-lives').textContent = gameLives;
            document.getElementById('game-level').textContent = gameLevel;
        }

        function shootBullet() {
            bullets.push({
                x: player.x,
                y: player.y - 10,
                width: bulletWidth,
                height: bulletHeight
            });
        }

        function spawnEnemy() {
            const size = 30 + Math.random() * 20;
            enemies.push({
                x: Math.random() * (gameCanvas.width - size),
                y: -size,
                width: size,
                height: size,
                speed: enemySpeed + gameLevel * 0.5,
                color: `hsl(${Math.random() * 60}, 80%, 50%)` // Red-orange enemies
            });
        }

        // Draw sleek nerdy spaceship (vector art, blue glow)
        function drawPlayer() {
            gameCtx.save();
            gameCtx.translate(player.x, player.y);

            // Blue glow effect
            gameCtx.shadowColor = '#00ffff';
            gameCtx.shadowBlur = 20;

            // Main body (sleek triangle)
            gameCtx.beginPath();
            gameCtx.moveTo(0, -25); // Nose
            gameCtx.lineTo(-15, 15); // Left wing
            gameCtx.lineTo(-5, 20); // Left bottom
            gameCtx.lineTo(5, 20); // Right bottom
            gameCtx.lineTo(15, 15); // Right wing
            gameCtx.closePath();

            const gradient = gameCtx.createLinearGradient(0, -25, 0, 20);
            gradient.addColorStop(0, '#00ffff');
            gradient.addColorStop(0.5, '#0088ff');
            gradient.addColorStop(1, '#0044ff');
            gameCtx.fillStyle = gradient;
            gameCtx.fill();

            // Cockpit window
            gameCtx.fillStyle = '#88ffff';
            gameCtx.beginPath();
            gameCtx.arc(0, -10, 5, 0, Math.PI * 2);
            gameCtx.fill();

            // Wings accent
            gameCtx.strokeStyle = '#00ffff';
            gameCtx.lineWidth = 2;
            gameCtx.beginPath();
            gameCtx.moveTo(-15, 15);
            gameCtx.lineTo(0, -25);
            gameCtx.lineTo(15, 15);
            gameCtx.stroke();

            // Engine glow
            gameCtx.shadowBlur = 15;
            gameCtx.fillStyle = '#0099ff';
            gameCtx.fillRect(-4, 20, 3, 8);
            gameCtx.fillRect(1, 20, 3, 8);

            gameCtx.restore();
        }

        function drawBullets() {
            gameCtx.fillStyle = '#00ffff';
            gameCtx.shadowColor = '#00ffff';
            gameCtx.shadowBlur = 10;

            bullets.forEach(bullet => {
                gameCtx.fillRect(bullet.x - bullet.width / 2, bullet.y, bullet.width, bullet.height);
            });

            gameCtx.shadowBlur = 0;
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                gameCtx.save();
                gameCtx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);

                // Enemy ship (simple hostile design)
                gameCtx.fillStyle = enemy.color;
                gameCtx.shadowColor = enemy.color;
                gameCtx.shadowBlur = 10;

                // Triangular hostile ship
                gameCtx.beginPath();
                gameCtx.moveTo(0, enemy.height / 2); // Bottom point
                gameCtx.lineTo(-enemy.width / 2, -enemy.height / 2); // Top left
                gameCtx.lineTo(enemy.width / 2, -enemy.height / 2); // Top right
                gameCtx.closePath();
                gameCtx.fill();

                // Red glow eyes
                gameCtx.fillStyle = '#ff0000';
                gameCtx.beginPath();
                gameCtx.arc(-5, -5, 2, 0, Math.PI * 2);
                gameCtx.arc(5, -5, 2, 0, Math.PI * 2);
                gameCtx.fill();

                gameCtx.restore();
            });
        }

        function updateGame() {
            // Move player
            if (player.moveLeft) player.x -= player.speed;
            if (player.moveRight) player.x += player.speed;

            // Keep player in bounds
            player.x = Math.max(20, Math.min(gameCanvas.width - 20, player.x));

            // Update bullets
            for (let i = bullets.length - 1; i >= 0; i--) {
                bullets[i].y -= bulletSpeed;
                if (bullets[i].y < 0) bullets.splice(i, 1);
            }

            // Update enemies
            for (let i = enemies.length - 1; i >= 0; i--) {
                enemies[i].y += enemies[i].speed;

                // Remove if off screen
                if (enemies[i].y > gameCanvas.height) {
                    enemies.splice(i, 1);
                    gameLives--;
                    updateGameUI();
                    if (gameLives <= 0) endGame();
                }
            }

            // Collision detection
            for (let i = bullets.length - 1; i >= 0; i--) {
                for (let j = enemies.length - 1; j >= 0; j--) {
                    const bullet = bullets[i];
                    const enemy = enemies[j];

                    if (bullet && enemy &&
                        bullet.x > enemy.x &&
                        bullet.x < enemy.x + enemy.width &&
                        bullet.y > enemy.y &&
                        bullet.y < enemy.y + enemy.height) {

                        bullets.splice(i, 1);
                        enemies.splice(j, 1);
                        gameScore += 10;
                        updateGameUI();

                        // Level up every 500 points
                        if (gameScore > 0 && gameScore % 500 === 0) {
                            gameLevel++;
                            enemySpawnRate = Math.max(20, enemySpawnRate - 5);
                            updateGameUI();
                        }
                        break;
                    }
                }
            }

            // Spawn enemies
            if (Math.random() < 1 / enemySpawnRate) {
                spawnEnemy();
            }
        }

        let gameFrameCount = 0;
        function gameLoop() {
            if (!gameActive) return;

            gameFrameCount++;

            // Clear canvas
            gameCtx.fillStyle = '#000';
            gameCtx.fillRect(0, 0, gameCanvas.width, gameCanvas.height);

            // Draw starfield background
            gameCtx.fillStyle = '#ffffff';
            for (let i = 0; i < 50; i++) {
                const x = (i * 37) % gameCanvas.width;
                const y = (gameFrameCount * 2 + i * 17) % gameCanvas.height;
                gameCtx.fillRect(x, y, 1, 1);
            }

            updateGame();
            drawEnemies();
            drawBullets();
            drawPlayer();

            requestAnimationFrame(gameLoop);
        }

        // Exit game button handler
        const exitGameBtn = document.getElementById('exit-game-btn');
        if (exitGameBtn) {
            exitGameBtn.addEventListener('click', () => {
                console.log('üéÆ GAME: Exit button clicked');

                // Stop the game
                gameActive = false;

                // Fade out game zone
                gameZone.style.opacity = '0';
                gameZone.style.pointerEvents = 'none';
                gameZoneActivated = false;

                // Scroll to top of page
                window.scrollTo({
                    top: 0,
                    behavior: 'smooth'
                });

                console.log('üéÆ GAME: Exited game, scrolling to top');
            });
        }
    </script>
</body>
</html>