<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>📊 NERD GRID ANALYTICS - Deep Data Intelligence</title>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700;900&display=swap" rel="stylesheet">
    <style>
        :root {
            --nerd-gold: #ffd700;
            --nerd-cyan: #00ffff;
            --nerd-green: #00ff41;
            --terminal-bg: #0a0a0a;
            --terminal-secondary: #1a1a1a;
            --terminal-border: #333333;
        }

        body {
            background: var(--terminal-bg);
            color: var(--nerd-green);
            font-family: 'Source Code Pro', monospace;
            margin: 0;
            padding: 0;
            min-height: 100vh;
        }

        .terminal-container {
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .terminal-header {
            background: var(--terminal-secondary);
            border: 2px solid var(--nerd-green);
            padding: 20px;
            margin-bottom: 20px;
            text-align: center;
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.3);
        }

        .terminal-title {
            font-size: 28px;
            font-weight: 900;
            color: var(--nerd-gold);
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            margin-bottom: 10px;
        }

        .terminal-subtitle {
            font-size: 16px;
            color: var(--nerd-cyan);
            opacity: 0.8;
        }

        .analytics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .analytics-panel {
            background: var(--terminal-secondary);
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }

        .panel-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--nerd-gold);
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 1px solid var(--terminal-border);
            padding-bottom: 10px;
        }

        .chart-container {
            position: relative;
            height: 300px;
            margin: 10px 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: #111111;
            border: 1px solid var(--terminal-border);
            padding: 10px;
            text-align: center;
            border-radius: 4px;
        }

        .stat-value {
            color: var(--nerd-gold);
            font-weight: 700;
            font-size: 20px;
            display: block;
        }

        .stat-label {
            color: #888888;
            font-size: 11px;
            text-transform: uppercase;
            margin-top: 5px;
        }

        .control-panel {
            background: var(--terminal-secondary);
            border: 1px solid var(--terminal-border);
            padding: 20px;
            margin-bottom: 20px;
            border-radius: 8px;
        }

        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            align-items: center;
        }

        .terminal-button {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            border: 1px solid var(--nerd-green);
            color: var(--nerd-green);
            padding: 12px 20px;
            font-family: 'Source Code Pro', monospace;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 4px;
            text-transform: uppercase;
            font-size: 12px;
        }

        .terminal-button:hover {
            background: linear-gradient(135deg, var(--nerd-green) 0%, #00cc33 100%);
            color: var(--terminal-bg);
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.5);
        }

        .terminal-button.active {
            background: linear-gradient(135deg, var(--nerd-gold) 0%, #ffb700 100%);
            color: var(--terminal-bg);
            border-color: var(--nerd-gold);
        }

        .week-selector {
            background: var(--terminal-bg);
            border: 1px solid var(--terminal-border);
            color: var(--nerd-green);
            padding: 8px 12px;
            font-family: 'Source Code Pro', monospace;
            border-radius: 4px;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .loading-content {
            background: var(--terminal-secondary);
            border: 2px solid var(--nerd-green);
            padding: 30px;
            border-radius: 8px;
            text-align: center;
        }

        .loading-spinner {
            border: 3px solid var(--terminal-border);
            border-top: 3px solid var(--nerd-green);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .performance-meter {
            background: #111111;
            border: 1px solid var(--terminal-border);
            padding: 15px;
            margin: 10px 0;
            border-radius: 4px;
        }

        .meter-bar {
            background: var(--terminal-border);
            height: 20px;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .meter-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444 0%, #ffaa00 50%, #00ff41 100%);
            transition: width 0.8s ease;
            border-radius: 10px;
        }

        .meter-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            font-weight: 700;
            color: white;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.8);
        }

        .insight-panel {
            background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%);
            border: 1px solid var(--nerd-cyan);
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }

        .insight-title {
            color: var(--nerd-cyan);
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }

        .insight-icon {
            margin-right: 10px;
            font-size: 20px;
        }

        .insight-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .insight-item {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 255, 255, 0.2);
            color: #cccccc;
            font-size: 14px;
        }

        .insight-item:last-child {
            border-bottom: none;
        }

        .table-container {
            background: var(--terminal-secondary);
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            margin: 20px 0;
            overflow: hidden;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .data-table th {
            background: var(--terminal-bg);
            color: var(--nerd-gold);
            padding: 12px 8px;
            border-bottom: 1px solid var(--terminal-border);
            font-weight: 700;
            text-align: left;
        }

        .data-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(51, 51, 51, 0.5);
            color: var(--nerd-green);
        }

        .data-table tr:hover {
            background: rgba(0, 255, 65, 0.1);
        }

        .tony-highlight {
            background: linear-gradient(135deg, rgba(0, 206, 209, 0.2) 0%, rgba(52, 152, 219, 0.2) 100%) !important;
            border-left: 3px solid var(--nerd-cyan) !important;
        }

        .hidden {
            display: none;
        }

        /* Utility Classes */
        .flex { display: flex; }
        .gap-2 { gap: 8px; }
        .gap-4 { gap: 16px; }
        .p-4 { padding: 16px; }
        .p-6 { padding: 24px; }
        .mt-4 { margin-top: 16px; }
        .mb-2 { margin-bottom: 8px; }
        .mb-4 { margin-bottom: 16px; }
        .text-center { text-align: center; }
        .text-sm { font-size: 14px; }
        .font-bold { font-weight: 700; }
        .block { display: block; }
        .hidden { display: none; }

        /* CSS-Based Chart Styles */
        .css-chart {
            background: var(--terminal-secondary);
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            padding: 30px;
            height: 400px;
            overflow-y: auto;
        }

        .chart-bar {
            background: linear-gradient(90deg, var(--nerd-green), var(--nerd-gold));
            height: 50px;
            margin: 20px 0;
            border-radius: 8px;
            position: relative;
            transition: all 0.5s ease;
            min-width: 80px;
        }

        .chart-bar-label {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--terminal-bg);
            font-weight: 700;
            font-size: 20px;
        }

        .chart-bar-value {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--terminal-bg);
            font-weight: 700;
            font-size: 20px;
        }

        .chart-title {
            color: var(--nerd-gold);
            font-weight: 700;
            font-size: 20px;
            margin-bottom: 25px;
            text-align: center;
        }

        .css-line-chart {
            background: var(--terminal-secondary);
            border: 1px solid var(--terminal-border);
            border-radius: 8px;
            padding: 20px;
            height: 300px;
            position: relative;
            overflow: hidden;
        }

        .line-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--nerd-gold);
            border-radius: 50%;
            border: 2px solid var(--nerd-green);
            transform: translate(-50%, -50%);
        }

        .line-segment {
            position: absolute;
            height: 2px;
            background: var(--nerd-green);
            transform-origin: left center;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }

            .control-grid {
                grid-template-columns: 1fr;
            }

            .terminal-title {
                font-size: 20px;
            }

            .chart-container {
                height: 250px;
            }

            .flex {
                flex-direction: column;
            }

            .gap-2 {
                gap: 4px;
            }
        }
    </style>
</head>
<body>
    <div class="terminal-container">
        <!-- Terminal Header -->
        <div class="terminal-header">
            <div class="terminal-title">📊 NERD GRID ANALYTICS</div>
            <div class="terminal-subtitle">Deep Data Intelligence • Performance Analysis • Strategic Insights</div>
        </div>

        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-grid">
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">WEEK SELECTION:</label>
                    <select id="weekSelector" class="week-selector">
                        <option value="4">Week 4 (Current)</option>
                        <option value="3">Week 3</option>
                        <option value="2">Week 2</option>
                        <option value="1">Week 1</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">ANALYTICS MODE:</label>
                    <div class="flex gap-2">
                        <button id="btnPerformance" class="terminal-button active" onclick="switchAnalyticsMode('performance')">PERFORMANCE</button>
                        <button id="btnRisk" class="terminal-button" onclick="switchAnalyticsMode('risk')">RISK ANALYSIS</button>
                        <button id="btnTrends" class="terminal-button" onclick="switchAnalyticsMode('trends')">TRENDS</button>
                    </div>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">DATA REFRESH:</label>
                    <button id="btnRefresh" class="terminal-button" onclick="refreshAnalytics()">🔄 REFRESH DATA</button>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">CACHE STATUS:</label>
                    <button id="btnCacheStatus" class="terminal-button" onclick="showCacheStatus()">📊 CACHE STATUS</button>
                </div>
            </div>
        </div>

        <!-- Advanced Filter Controls -->
        <div class="control-panel">
            <div class="control-grid">
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">PLAYER FILTER:</label>
                    <select id="playerFilter" class="week-selector" onchange="applyFilters()">
                        <option value="all">All Players</option>
                        <option value="top5">Top 5 Performers</option>
                        <option value="bottom5">Bottom 5 Performers</option>
                        <option value="tony">Tony Only</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">GAME STATUS:</label>
                    <select id="gameStatusFilter" class="week-selector" onchange="applyFilters()">
                        <option value="all">All Games</option>
                        <option value="completed">Completed Only</option>
                        <option value="live">Live Games</option>
                        <option value="upcoming">Upcoming</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">CONFIDENCE LEVEL:</label>
                    <select id="confidenceFilter" class="week-selector" onchange="applyFilters()">
                        <option value="all">All Confidence</option>
                        <option value="high">High (12-16)</option>
                        <option value="medium">Medium (7-11)</option>
                        <option value="low">Low (1-6)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm mb-2" style="color: #888;">CHART OPTIONS:</label>
                    <div class="flex gap-2">
                        <button id="btnAnimations" class="terminal-button active" onclick="toggleAnimations()">🎬 ANIMATE</button>
                        <button id="btnExport" class="terminal-button" onclick="exportData()">📤 EXPORT</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick Stats Overview -->
        <div class="analytics-panel">
            <div class="panel-title">📈 REAL-TIME GRID METRICS</div>
            <div class="stats-grid" id="quickStats">
                <div class="stat-box">
                    <span class="stat-value" id="totalPlayers">--</span>
                    <div class="stat-label">Total Players</div>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="totalGames">--</span>
                    <div class="stat-label">Games This Week</div>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="completedGames">--</span>
                    <div class="stat-label">Completed Games</div>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="avgScore">--</span>
                    <div class="stat-label">Avg Score</div>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="topScore">--</span>
                    <div class="stat-label">High Score</div>
                </div>
                <div class="stat-box">
                    <span class="stat-value" id="cacheHitRate">--</span>
                    <div class="stat-label">Cache Hit Rate</div>
                </div>
            </div>
        </div>

        <!-- Simplified Analytics Grid - 4 Core Charts -->
        <div class="analytics-grid">
            <!-- Player Leaderboard -->
            <div class="analytics-panel">
                <div class="panel-title">🏆 TOP PERFORMERS</div>
                <div class="css-chart" id="performanceMatrixChart">
                    <div style="color: #888; text-align: center; margin-top: 80px; font-size: 22px;">Loading performance data...</div>
                </div>
            </div>

            <!-- Pick Accuracy -->
            <div class="analytics-panel">
                <div class="panel-title">🎯 ACCURACY ANALYSIS</div>
                <div class="css-chart" id="accuracyTrendsChart">
                    <div style="color: #888; text-align: center; margin-top: 80px; font-size: 22px;">Loading accuracy data...</div>
                </div>
            </div>

            <!-- Confidence Strategy -->
            <div class="analytics-panel">
                <div class="panel-title">🧠 CONFIDENCE INTEL</div>
                <div class="css-chart" id="confidenceStrategyChart">
                    <div style="color: #888; text-align: center; margin-top: 80px; font-size: 22px;">Loading confidence data...</div>
                </div>
            </div>

            <!-- Score Distribution -->
            <div class="analytics-panel">
                <div class="panel-title">📊 SCORE BREAKDOWN</div>
                <div class="css-chart" id="scoreDistributionChart">
                    <div style="color: #888; text-align: center; margin-top: 80px; font-size: 22px;">Loading score data...</div>
                </div>
            </div>
        </div>

        <!-- Performance Insights Panel -->
        <div class="insight-panel">
            <div class="insight-title">
                <span class="insight-icon">🔍</span>
                STRATEGIC INSIGHTS & ANALYTICS
            </div>
            <ul class="insight-list" id="insightsList">
                <li class="insight-item">Loading strategic insights...</li>
            </ul>
        </div>

        <!-- Detailed Performance Table -->
        <div class="table-container">
            <table class="data-table" id="performanceTable">
                <thead>
                    <tr>
                        <th>RANK</th>
                        <th>PLAYER</th>
                        <th>TOTAL PTS</th>
                        <th>ACCURACY</th>
                        <th>HIGH CONF</th>
                        <th>RISK FACTOR</th>
                        <th>TREND</th>
                        <th>PICK STYLE</th>
                    </tr>
                </thead>
                <tbody id="performanceTableBody">
                    <tr><td colspan="8" style="text-align: center; padding: 20px;">Loading performance data...</td></tr>
                </tbody>
            </table>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="loading-content">
            <div class="loading-spinner"></div>
            <div style="color: #00ff41; font-weight: 700;">ANALYZING GRID DATA...</div>
            <div style="color: #888; font-size: 12px; margin-top: 10px;">Crunching numbers at diamond level precision</div>
        </div>
    </div>

    <!-- Firebase Configuration -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import {
            getFirestore,
            doc,
            getDoc,
            collection,
            getDocs
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
        import {
            getAuth,
            onAuthStateChanged
        } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyDAF1MbAhL2uPIVUGMDlXvCqtknUUCX5Gw",
            authDomain: "nerdfootball.firebaseapp.com",
            databaseURL: "https://nerdfootball-default-rtdb.firebaseio.com",
            projectId: "nerdfootball",
            storageBucket: "nerdfootball.appspot.com",
            messagingSenderId: "969304790725",
            appId: "1:969304790725:web:892df38db0b0e62bde02ac"
        };

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);

        window.db = db;
        window.auth = auth;
        window.getDoc = getDoc;
        window.doc = doc;
        window.collection = collection;
        window.getDocs = getDocs;

        console.log('🔥 Firebase initialized for Grid Analytics');
    </script>

    <script>
        // 📊 GRID ANALYTICS CORE SYSTEM

        let currentWeek = 4;
        let poolMembers = {};
        let bibleData = {};
        let allPicks = {};
        let gameIds = [];
        let analyticsMode = 'performance';
        let charts = {};

        // 🎯 PERFORMANCE TRACKING
        const performanceMetrics = {
            loadStartTime: null,
            cacheHits: 0,
            cacheMisses: 0,
            dataPoints: 0
        };

        async function initialize() {
            console.log('📊 GRID_ANALYTICS: Initializing...');
            performanceMetrics.loadStartTime = Date.now();

            showLoading(true);

            try {
                await loadPoolMembers();
                await loadBibleData();
                await loadAllPicks();
                await generateAnalytics();

                setupEventListeners();

                const loadTime = Date.now() - performanceMetrics.loadStartTime;
                console.log(`✅ GRID_ANALYTICS: Initialized in ${loadTime}ms`);

            } catch (error) {
                console.error('❌ GRID_ANALYTICS ERROR:', error);
                showError('Failed to load grid analytics data');
            } finally {
                showLoading(false);
            }
        }

        async function loadPoolMembers() {
            try {
                const poolId = 'nerduniverse-2025';
                const poolMembersPath = `artifacts/nerdfootball/pools/${poolId}/metadata/members`;

                const membersDoc = await getDoc(doc(db, poolMembersPath));

                if (membersDoc.exists()) {
                    poolMembers = membersDoc.data();
                    console.log('✅ ANALYTICS: Pool members loaded:', Object.keys(poolMembers).length);
                    performanceMetrics.cacheHits++;
                } else {
                    throw new Error('Pool members not found');
                }
            } catch (error) {
                console.error('❌ ANALYTICS ERROR in loadPoolMembers():', error);
                performanceMetrics.cacheMisses++;
                throw error;
            }
        }

        async function loadBibleData() {
            try {
                const gamesPath = `artifacts/nerdfootball/public/data/nerdfootball_games/${currentWeek}`;
                const gamesDoc = await getDoc(doc(db, gamesPath));

                if (!gamesDoc.exists()) {
                    throw new Error(`No games data found for week ${currentWeek}`);
                }

                bibleData = gamesDoc.data();

                gameIds = Object.keys(bibleData)
                    .filter(k => !k.startsWith('_') && !k.includes('401772'))
                    .filter(k => {
                        const gameNum = parseInt(k);
                        const weekStart = currentWeek * 100 + 1;
                        const weekEnd = currentWeek * 100 + 16;
                        return gameNum >= weekStart && gameNum <= weekEnd;
                    })
                    .sort((a, b) => parseInt(a) - parseInt(b));

                console.log('✅ ANALYTICS: Bible data loaded:', gameIds.length, 'games');
                performanceMetrics.cacheHits++;

            } catch (error) {
                console.error('❌ ANALYTICS ERROR in loadBibleData():', error);
                performanceMetrics.cacheMisses++;
                throw error;
            }
        }

        async function loadAllPicks() {
            const memberIds = Object.keys(poolMembers);
            console.log('🔍 ANALYTICS: Loading picks for', memberIds.length, 'members');

            const pickPromises = memberIds.map(async (memberId) => {
                try {
                    const picksPath = `artifacts/nerdfootball/public/data/nerdfootball_picks/${currentWeek}/submissions/${memberId}`;
                    const userPicksDoc = await getDoc(doc(db, picksPath));
                    if (userPicksDoc.exists()) {
                        allPicks[memberId] = userPicksDoc.data();
                        performanceMetrics.cacheHits++;
                    } else {
                        allPicks[memberId] = null;
                    }
                } catch (error) {
                    console.error(`❌ ANALYTICS: Error loading picks for ${memberId}:`, error);
                    allPicks[memberId] = null;
                    performanceMetrics.cacheMisses++;
                }
            });

            await Promise.all(pickPromises);
            console.log('✅ ANALYTICS: Picks loaded for', Object.keys(allPicks).length, 'users');
        }

        async function generateAnalytics() {
            console.log('📊 ANALYTICS: Generating CSS-based analytics...');

            updateQuickStats();

            // 4 Core Charts Only - Simplified per user request
            generateCSSPerformanceMatrix();    // 🏆 TOP PERFORMERS
            generateCSSAccuracyTrends();       // 🎯 ACCURACY ANALYSIS
            generateCSSConfidenceStrategy();   // 🧠 CONFIDENCE INTEL
            generateCSSScoreDistribution();    // 📊 SCORE BREAKDOWN

            console.log('✅ ANALYTICS: All CSS charts and insights generated');
        }

        function updateQuickStats() {
            const memberIds = Object.keys(poolMembers);
            const completedGames = gameIds.filter(gameId => {
                const game = bibleData[gameId];
                return game && game.status && game.status.type && game.status.type.completed;
            }).length;

            // Calculate scores
            const scores = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return 0;

                let totalScore = 0;
                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        // Simplified scoring logic
                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalScore += parseInt(pick.confidence) || 1;
                            }
                        }
                    }
                });
                return totalScore;
            }).filter(score => score > 0);

            const avgScore = scores.length > 0 ? (scores.reduce((a, b) => a + b, 0) / scores.length).toFixed(1) : 0;
            const topScore = scores.length > 0 ? Math.max(...scores) : 0;
            const cacheHitRate = performanceMetrics.cacheHits + performanceMetrics.cacheMisses > 0
                ? ((performanceMetrics.cacheHits / (performanceMetrics.cacheHits + performanceMetrics.cacheMisses)) * 100).toFixed(1)
                : 100;

            document.getElementById('totalPlayers').textContent = memberIds.length;
            document.getElementById('totalGames').textContent = gameIds.length;
            document.getElementById('completedGames').textContent = completedGames;
            document.getElementById('avgScore').textContent = avgScore;
            document.getElementById('topScore').textContent = topScore;
            document.getElementById('cacheHitRate').textContent = cacheHitRate + '%';
        }

        function generateCSSScoreDistribution() {
            const container = document.getElementById('scoreDistributionChart');
            const memberIds = getFilteredMemberIds();

            const scores = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return 0;

                let totalScore = 0;
                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalScore += parseInt(pick.confidence) || 1;
                            }
                        }
                    }
                });
                return totalScore;
            });

            // Create score ranges
            const maxScore = Math.max(...scores) || 1;
            const ranges = [];
            const rangeCounts = [];
            const rangeSize = Math.max(5, Math.ceil(maxScore / 8));

            for (let i = 0; i <= maxScore; i += rangeSize) {
                const rangeLabel = `${i}-${i + rangeSize - 1}`;
                const count = scores.filter(score => score >= i && score < i + rangeSize).length;
                ranges.push(rangeLabel);
                rangeCounts.push(count);
            }

            const maxCount = Math.max(...rangeCounts) || 1;

            let html = '<div style="color: #ffd700; font-weight: 700; margin-bottom: 15px;">Score Distribution</div>';

            ranges.forEach((range, index) => {
                const count = rangeCounts[index];
                const percentage = (count / maxCount) * 100;
                html += `
                    <div class="chart-bar" style="width: ${percentage}%; margin-bottom: 8px;">
                        <span class="chart-bar-label">${range} pts</span>
                        <span class="chart-bar-value">${count} players</span>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function generateAccuracyTrends() {
            const ctx = document.getElementById('accuracyTrendsChart').getContext('2d');

            const allMemberIds = getFilteredMemberIds();
            const memberIds = allMemberIds.slice(0, 10); // Top 10 for readability
            const datasets = memberIds.map((memberId, index) => {
                const picks = allPicks[memberId];
                const accuracyData = [];

                if (picks) {
                    const completedGameIds = gameIds.filter(gameId => {
                        const game = bibleData[gameId];
                        return game && game.status && game.status.type && game.status.type.completed;
                    });

                    let correctPicks = 0;
                    completedGameIds.forEach((gameId, gameIndex) => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                correctPicks++;
                            }
                        }
                        accuracyData.push(gameIndex > 0 ? (correctPicks / (gameIndex + 1)) * 100 : 0);
                    });
                }

                const colors = [
                    '#00ff41', '#ffd700', '#00ffff', '#ff6b6b', '#4ecdc4',
                    '#45b7d1', '#f9ca24', '#6c5ce7', '#fd79a8', '#fdcb6e'
                ];

                return {
                    label: poolMembers[memberId]?.displayName || 'Unknown',
                    data: accuracyData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    fill: false,
                    tension: 0.1
                };
            });

            if (charts.accuracyTrends) {
                charts.accuracyTrends.destroy();
            }

            charts.accuracyTrends = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#00ff41', font: { size: 10 } }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Game Number', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Accuracy %', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        function generatePerformanceMatrix() {
            const ctx = document.getElementById('performanceMatrixChart').getContext('2d');

            const memberIds = Object.keys(poolMembers);
            const performanceData = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return { x: 0, y: 0, r: 5 };

                let totalScore = 0;
                let accuracy = 0;
                let totalPicks = 0;
                let correctPicks = 0;

                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        totalPicks++;
                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalScore += parseInt(pick.confidence) || 1;
                                correctPicks++;
                            }
                        }
                    }
                });

                accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;

                return {
                    x: totalScore,
                    y: accuracy,
                    r: Math.max(5, totalPicks * 2)
                };
            });

            if (charts.performanceMatrix) {
                charts.performanceMatrix.destroy();
            }

            charts.performanceMatrix = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Players',
                        data: performanceData,
                        backgroundColor: 'rgba(255, 215, 0, 0.6)',
                        borderColor: '#ffd700',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#00ff41' }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Total Score', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Accuracy %', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        function generateConfidenceStrategy() {
            const ctx = document.getElementById('confidenceStrategyChart').getContext('2d');

            const confidenceLevels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
            const successRates = confidenceLevels.map(confidence => {
                let total = 0;
                let correct = 0;

                Object.keys(poolMembers).forEach(memberId => {
                    const picks = allPicks[memberId];
                    if (!picks) return;

                    gameIds.forEach(gameId => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && pick.confidence == confidence && game && game.status && game.status.type && game.status.type.completed) {
                            total++;
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    correct++;
                                }
                            }
                        }
                    });
                });

                return total > 0 ? (correct / total) * 100 : 0;
            });

            if (charts.confidenceStrategy) {
                charts.confidenceStrategy.destroy();
            }

            charts.confidenceStrategy = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: confidenceLevels,
                    datasets: [{
                        label: 'Success Rate %',
                        data: successRates,
                        borderColor: '#00ffff',
                        backgroundColor: 'rgba(0, 255, 255, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: { color: '#00ff41' }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Confidence Level', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Success Rate %', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        function generateRiskRewardMatrix() {
            const ctx = document.getElementById('riskRewardChart').getContext('2d');

            const memberIds = Object.keys(poolMembers);
            const riskRewardData = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return { x: 0, y: 0, r: 5, label: 'Unknown' };

                let highRiskPicks = 0;
                let totalPicks = 0;
                let totalReward = 0;

                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        totalPicks++;
                        const confidence = parseInt(pick.confidence) || 1;

                        if (confidence >= 12) highRiskPicks++;

                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalReward += confidence;
                            }
                        }
                    }
                });

                const riskLevel = totalPicks > 0 ? (highRiskPicks / totalPicks) * 100 : 0;
                const rewardLevel = totalReward;

                return {
                    x: riskLevel,
                    y: rewardLevel,
                    r: Math.max(8, totalPicks * 1.5),
                    label: poolMembers[memberId]?.displayName || 'Unknown'
                };
            });

            if (charts.riskReward) {
                charts.riskReward.destroy();
            }

            charts.riskReward = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Risk vs Reward',
                        data: riskRewardData,
                        backgroundColor: 'rgba(255, 107, 107, 0.6)',
                        borderColor: '#ff6b6b',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#00ff41' } },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const point = context.raw;
                                    return `${point.label}: Risk ${point.x.toFixed(1)}%, Reward ${point.y}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Risk Level (%)', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Total Reward Points', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        }
                    }
                }
            });
        }

        function generateGameDifficultyHeatMap() {
            const ctx = document.getElementById('gameDifficultyChart').getContext('2d');

            const gameLabels = [];
            const difficultyData = [];

            gameIds.forEach(gameId => {
                const game = bibleData[gameId];
                if (!game || !game.competitions || !game.competitions[0]) return;

                const competition = game.competitions[0];
                const teams = competition.competitors.map(c => c.team.abbreviation).join(' vs ');
                gameLabels.push(teams);

                // Calculate difficulty based on pick distribution
                let totalPicks = 0;
                let pickDistribution = { team1: 0, team2: 0 };

                Object.keys(poolMembers).forEach(memberId => {
                    const picks = allPicks[memberId];
                    if (picks && picks[gameId] && picks[gameId].winner) {
                        totalPicks++;
                        const winner = picks[gameId].winner;
                        if (winner === competition.competitors[0].team.displayName) {
                            pickDistribution.team1++;
                        } else {
                            pickDistribution.team2++;
                        }
                    }
                });

                // Difficulty = how evenly split the picks are (50/50 = most difficult)
                const split = totalPicks > 0 ? Math.abs(50 - (pickDistribution.team1 / totalPicks * 100)) : 50;
                difficultyData.push(50 - split); // Invert so 50/50 split = high difficulty
            });

            if (charts.gameDifficulty) {
                charts.gameDifficulty.destroy();
            }

            charts.gameDifficulty = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: gameLabels,
                    datasets: [{
                        label: 'Difficulty Score',
                        data: difficultyData,
                        backgroundColor: difficultyData.map(d =>
                            d > 40 ? 'rgba(255, 107, 107, 0.8)' :
                            d > 20 ? 'rgba(255, 193, 7, 0.8)' :
                            'rgba(40, 167, 69, 0.8)'
                        ),
                        borderColor: '#00ff41',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',
                    plugins: {
                        legend: { labels: { color: '#00ff41' } }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Difficulty (0=Easy, 50=Very Hard)', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            ticks: { color: '#00ff41', font: { size: 10 } },
                            grid: { color: '#333333' }
                        }
                    }
                }
            });
        }

        function generateTonyRadarChart() {
            const ctx = document.getElementById('tonyRadarChart').getContext('2d');

            // Find Tony's user ID
            const tonyId = Object.keys(poolMembers).find(id =>
                poolMembers[id]?.displayName?.toLowerCase().includes('tony')
            );

            if (!tonyId || !allPicks[tonyId]) {
                ctx.fillStyle = '#00ff41';
                ctx.font = '16px Source Code Pro';
                ctx.textAlign = 'center';
                ctx.fillText('Tony not found in data', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }

            const picks = allPicks[tonyId];
            const metrics = {
                accuracy: 0,
                highConfidence: 0,
                riskTaking: 0,
                consistency: 0,
                contrarian: 0,
                efficiency: 0
            };

            let totalPicks = 0;
            let correctPicks = 0;
            let highConfPicks = 0;
            let highConfCorrect = 0;
            let confidences = [];

            gameIds.forEach(gameId => {
                const pick = picks[gameId];
                const game = bibleData[gameId];
                if (pick && game && game.status && game.status.type && game.status.type.completed) {
                    totalPicks++;
                    const confidence = parseInt(pick.confidence) || 1;
                    confidences.push(confidence);

                    if (confidence >= 12) {
                        highConfPicks++;
                    }

                    if (pick.winner && game.competitions && game.competitions[0]) {
                        const competition = game.competitions[0];
                        const actualWinner = competition.competitors.find(c => c.winner);
                        if (actualWinner && actualWinner.team.displayName === pick.winner) {
                            correctPicks++;
                            if (confidence >= 12) {
                                highConfCorrect++;
                            }
                        }
                    }
                }
            });

            // Calculate metrics (0-100 scale)
            metrics.accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;
            metrics.highConfidence = highConfPicks > 0 ? (highConfCorrect / highConfPicks) * 100 : 0;
            metrics.riskTaking = totalPicks > 0 ? (highConfPicks / totalPicks) * 100 : 0;
            metrics.consistency = confidences.length > 0 ?
                100 - (Math.sqrt(confidences.reduce((sum, c, i, arr) =>
                    sum + Math.pow(c - arr.reduce((a, b) => a + b, 0) / arr.length, 2), 0) / arr.length) / 5 * 100) : 0;
            metrics.contrarian = 25; // Simplified for now
            metrics.efficiency = metrics.accuracy * (1 + metrics.riskTaking / 100);

            if (charts.tonyRadar) {
                charts.tonyRadar.destroy();
            }

            charts.tonyRadar = new Chart(ctx, {
                type: 'radar',
                data: {
                    labels: ['Accuracy', 'High Confidence', 'Risk Taking', 'Consistency', 'Contrarian', 'Efficiency'],
                    datasets: [{
                        label: 'Tony\'s Performance',
                        data: Object.values(metrics),
                        backgroundColor: 'rgba(0, 206, 209, 0.2)',
                        borderColor: '#00ced1',
                        borderWidth: 3,
                        pointBackgroundColor: '#00ced1',
                        pointBorderColor: '#ffffff',
                        pointBorderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#00ff41' } }
                    },
                    scales: {
                        r: {
                            angleLines: { color: '#333333' },
                            grid: { color: '#333333' },
                            pointLabels: { color: '#00ff41', font: { size: 12 } },
                            ticks: { color: '#888888', display: false },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        function generateUpsetAlertSystem() {
            const ctx = document.getElementById('upsetAlertChart').getContext('2d');

            const gameLabels = [];
            const upsetPotential = [];
            const currentStatus = [];

            gameIds.forEach(gameId => {
                const game = bibleData[gameId];
                if (!game || !game.competitions || !game.competitions[0]) return;

                const competition = game.competitions[0];
                const teams = competition.competitors.map(c => c.team.abbreviation).join(' vs ');
                gameLabels.push(teams);

                // Calculate upset potential based on pick distribution vs actual result
                let majorityPick = null;
                let pickCounts = {};

                Object.keys(poolMembers).forEach(memberId => {
                    const picks = allPicks[memberId];
                    if (picks && picks[gameId] && picks[gameId].winner) {
                        const winner = picks[gameId].winner;
                        pickCounts[winner] = (pickCounts[winner] || 0) + 1;
                    }
                });

                const totalPicks = Object.values(pickCounts).reduce((a, b) => a + b, 0);
                if (totalPicks > 0) {
                    majorityPick = Object.keys(pickCounts).reduce((a, b) =>
                        pickCounts[a] > pickCounts[b] ? a : b
                    );
                }

                let upsetLevel = 0;
                let status = 'TBD';

                if (game.status && game.status.type && game.status.type.completed && majorityPick) {
                    const actualWinner = competition.competitors.find(c => c.winner);
                    if (actualWinner) {
                        const isUpset = actualWinner.team.displayName !== majorityPick;
                        const majorityPercentage = (pickCounts[majorityPick] / totalPicks) * 100;
                        upsetLevel = isUpset ? majorityPercentage : 0;
                        status = isUpset ? 'UPSET!' : 'Expected';
                    }
                } else if (majorityPick) {
                    upsetLevel = (pickCounts[majorityPick] / totalPicks) * 100;
                    status = 'Live';
                }

                upsetPotential.push(upsetLevel);
                currentStatus.push(status);
            });

            if (charts.upsetAlert) {
                charts.upsetAlert.destroy();
            }

            charts.upsetAlert = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: gameLabels,
                    datasets: [{
                        label: 'Upset Potential %',
                        data: upsetPotential,
                        backgroundColor: upsetPotential.map((level, i) =>
                            currentStatus[i] === 'UPSET!' ? 'rgba(255, 0, 0, 0.8)' :
                            level > 70 ? 'rgba(255, 193, 7, 0.8)' :
                            'rgba(40, 167, 69, 0.8)'
                        ),
                        borderColor: '#00ff41',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#00ff41' } },
                        tooltip: {
                            callbacks: {
                                afterLabel: function(context) {
                                    return `Status: ${currentStatus[context.dataIndex]}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: { color: '#00ff41', font: { size: 10 } },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Upset Potential %', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' },
                            max: 100
                        }
                    }
                }
            });
        }

        function generateConsensusTracker() {
            let mostPopularPick = 'Loading...';
            let contrarians = 0;
            let sheepMeter = 0;

            // Calculate consensus data
            const pickConsensus = {};
            let totalPicksMade = 0;

            gameIds.forEach(gameId => {
                const gamePicks = {};
                Object.keys(poolMembers).forEach(memberId => {
                    const picks = allPicks[memberId];
                    if (picks && picks[gameId] && picks[gameId].winner) {
                        const winner = picks[gameId].winner;
                        gamePicks[winner] = (gamePicks[winner] || 0) + 1;
                        totalPicksMade++;
                    }
                });
                pickConsensus[gameId] = gamePicks;
            });

            // Find most popular pick overall
            const allPicks_flat = {};
            Object.values(pickConsensus).forEach(gamePicks => {
                Object.entries(gamePicks).forEach(([team, count]) => {
                    allPicks_flat[team] = (allPicks_flat[team] || 0) + count;
                });
            });

            if (Object.keys(allPicks_flat).length > 0) {
                mostPopularPick = Object.keys(allPicks_flat).reduce((a, b) =>
                    allPicks_flat[a] > allPicks_flat[b] ? a : b
                );

                // Calculate contrarian picks and sheep meter
                const maxPicks = Math.max(...Object.values(allPicks_flat));
                sheepMeter = totalPicksMade > 0 ? (maxPicks / totalPicksMade * 100).toFixed(1) : 0;

                // Count picks that go against the majority
                Object.values(pickConsensus).forEach(gamePicks => {
                    const totalGamePicks = Object.values(gamePicks).reduce((a, b) => a + b, 0);
                    const maxGamePicks = Math.max(...Object.values(gamePicks));
                    contrarians += totalGamePicks - maxGamePicks;
                });
            }

            document.getElementById('mostPopularPick').textContent = mostPopularPick;
            document.getElementById('contrarians').textContent = contrarians;
            document.getElementById('sheepMeter').textContent = sheepMeter + '%';
        }

        function generateMomentumAnalyzer() {
            const ctx = document.getElementById('momentumChart').getContext('2d');

            const memberIds = Object.keys(poolMembers).slice(0, 8); // Top performers
            const datasets = memberIds.map((memberId, index) => {
                const picks = allPicks[memberId];
                const momentumData = [];

                if (picks) {
                    let runningScore = 0;
                    gameIds.forEach((gameId, gameIndex) => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && game && game.status && game.status.type && game.status.type.completed) {
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    runningScore += parseInt(pick.confidence) || 1;
                                }
                            }
                        }
                        momentumData.push(runningScore);
                    });
                }

                const colors = [
                    '#00ff41', '#ffd700', '#00ffff', '#ff6b6b', '#4ecdc4',
                    '#45b7d1', '#f9ca24', '#6c5ce7'
                ];

                return {
                    label: poolMembers[memberId]?.displayName || 'Unknown',
                    data: momentumData,
                    borderColor: colors[index % colors.length],
                    backgroundColor: colors[index % colors.length] + '20',
                    fill: false,
                    tension: 0.3
                };
            });

            if (charts.momentum) {
                charts.momentum.destroy();
            }

            charts.momentum = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#00ff41', font: { size: 10 } } }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Game Progression', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Cumulative Score', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        }
                    }
                }
            });
        }

        function generateEfficiencyMatrix() {
            const ctx = document.getElementById('efficiencyChart').getContext('2d');

            const memberIds = Object.keys(poolMembers);
            const efficiencyData = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return { x: 0, y: 0, r: 5 };

                let totalPossible = 0;
                let totalActual = 0;
                let pickCount = 0;

                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        const confidence = parseInt(pick.confidence) || 1;
                        totalPossible += confidence;
                        pickCount++;

                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalActual += confidence;
                            }
                        }
                    }
                });

                const efficiency = totalPossible > 0 ? (totalActual / totalPossible) * 100 : 0;
                const avgConfidence = pickCount > 0 ? totalPossible / pickCount : 0;

                return {
                    x: avgConfidence,
                    y: efficiency,
                    r: Math.max(6, pickCount * 1.5)
                };
            });

            if (charts.efficiency) {
                charts.efficiency.destroy();
            }

            charts.efficiency = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Pick Efficiency',
                        data: efficiencyData,
                        backgroundColor: 'rgba(76, 201, 196, 0.6)',
                        borderColor: '#4ecdc4',
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#00ff41' } }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Average Confidence', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' }
                        },
                        y: {
                            title: { display: true, text: 'Efficiency %', color: '#00ff41' },
                            ticks: { color: '#00ff41' },
                            grid: { color: '#333333' },
                            min: 0,
                            max: 100
                        }
                    }
                }
            });
        }

        function generateLiveGameImpact() {
            let liveGames = 0;
            let potentialSwings = 0;

            gameIds.forEach(gameId => {
                const game = bibleData[gameId];
                if (game && game.status && game.status.type && !game.status.type.completed) {
                    liveGames++;

                    // Calculate potential point swings for this game
                    Object.keys(poolMembers).forEach(memberId => {
                        const picks = allPicks[memberId];
                        if (picks && picks[gameId] && picks[gameId].confidence) {
                            potentialSwings += parseInt(picks[gameId].confidence) || 1;
                        }
                    });
                }
            });

            // Update live impact meter
            const impactPercentage = gameIds.length > 0 ? (liveGames / gameIds.length) * 100 : 0;
            document.getElementById('liveImpactMeter').style.width = impactPercentage + '%';
            document.getElementById('liveImpactText').textContent = `${impactPercentage.toFixed(1)}% Active`;

            document.getElementById('liveGames').textContent = liveGames;
            document.getElementById('potentialSwings').textContent = potentialSwings;
        }

        function generateInsights() {
            const insights = [];
            const memberIds = Object.keys(poolMembers);

            // Calculate various metrics for insights
            const scores = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                if (!picks) return { memberId, score: 0, accuracy: 0 };

                let totalScore = 0;
                let correctPicks = 0;
                let totalPicks = 0;

                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        totalPicks++;
                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalScore += parseInt(pick.confidence) || 1;
                                correctPicks++;
                            }
                        }
                    }
                });

                return {
                    memberId,
                    score: totalScore,
                    accuracy: totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0,
                    totalPicks
                };
            }).filter(player => player.totalPicks > 0).sort((a, b) => b.score - a.score);

            if (scores.length > 0) {
                const leader = scores[0];
                const leaderName = poolMembers[leader.memberId]?.displayName || 'Unknown';
                insights.push(`🏆 Current leader: ${leaderName} with ${leader.score} points (${leader.accuracy.toFixed(1)}% accuracy)`);

                const avgAccuracy = scores.reduce((sum, p) => sum + p.accuracy, 0) / scores.length;
                insights.push(`📊 Pool average accuracy: ${avgAccuracy.toFixed(1)}%`);

                const highAccuracyPlayers = scores.filter(p => p.accuracy > avgAccuracy + 10);
                if (highAccuracyPlayers.length > 0) {
                    insights.push(`🎯 ${highAccuracyPlayers.length} players performing above average (+10%)`);
                }

                const completedGames = gameIds.filter(gameId => {
                    const game = bibleData[gameId];
                    return game && game.status && game.status.type && game.status.type.completed;
                }).length;

                insights.push(`⚡ ${completedGames} of ${gameIds.length} games completed this week`);

                const cacheEfficiency = performanceMetrics.cacheHits / (performanceMetrics.cacheHits + performanceMetrics.cacheMisses) * 100;
                insights.push(`🚀 Cache system operating at ${cacheEfficiency.toFixed(1)}% efficiency`);

                const loadTime = Date.now() - performanceMetrics.loadStartTime;
                insights.push(`⚡ Analytics generated in ${loadTime}ms (Diamond Level: <500ms target)`);
            }

            const insightsList = document.getElementById('insightsList');
            insightsList.innerHTML = insights.map(insight => `<li class="insight-item">${insight}</li>`).join('');
        }

        function generatePerformanceTable() {
            const memberIds = Object.keys(poolMembers);
            const tableData = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                const displayName = poolMembers[memberId]?.displayName || 'Unknown';

                if (!picks) {
                    return {
                        memberId,
                        displayName,
                        score: 0,
                        accuracy: 0,
                        highConfidence: 0,
                        riskFactor: 'Low',
                        trend: '→',
                        pickStyle: 'Conservative'
                    };
                }

                let totalScore = 0;
                let correctPicks = 0;
                let totalPicks = 0;
                let highConfidencePicks = 0;
                let highConfidenceCorrect = 0;

                gameIds.forEach(gameId => {
                    const pick = picks[gameId];
                    const game = bibleData[gameId];
                    if (pick && game && game.status && game.status.type && game.status.type.completed) {
                        totalPicks++;
                        const confidence = parseInt(pick.confidence) || 1;

                        if (confidence >= 12) {
                            highConfidencePicks++;
                        }

                        if (pick.winner && game.competitions && game.competitions[0]) {
                            const competition = game.competitions[0];
                            const actualWinner = competition.competitors.find(c => c.winner);
                            if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                totalScore += confidence;
                                correctPicks++;
                                if (confidence >= 12) {
                                    highConfidenceCorrect++;
                                }
                            }
                        }
                    }
                });

                const accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;
                const highConfidenceAccuracy = highConfidencePicks > 0 ? (highConfidenceCorrect / highConfidencePicks) * 100 : 0;
                const riskFactor = highConfidencePicks > totalPicks * 0.3 ? 'High' : highConfidencePicks > totalPicks * 0.1 ? 'Medium' : 'Low';
                const pickStyle = accuracy > 70 ? 'Analytical' : accuracy > 50 ? 'Balanced' : 'Aggressive';

                return {
                    memberId,
                    displayName,
                    score: totalScore,
                    accuracy: accuracy.toFixed(1),
                    highConfidence: highConfidenceAccuracy.toFixed(1),
                    riskFactor,
                    trend: '→', // Simplified for now
                    pickStyle
                };
            }).sort((a, b) => b.score - a.score);

            const tbody = document.getElementById('performanceTableBody');
            tbody.innerHTML = tableData.map((player, index) => {
                const rowClass = player.displayName.toLowerCase().includes('tony') ? 'tony-highlight' : '';
                return `
                    <tr class="${rowClass}">
                        <td>${index + 1}</td>
                        <td style="font-weight: 700;">${player.displayName}</td>
                        <td style="color: #ffd700; font-weight: 700;">${player.score}</td>
                        <td>${player.accuracy}%</td>
                        <td>${player.highConfidence}%</td>
                        <td>${player.riskFactor}</td>
                        <td>${player.trend}</td>
                        <td>${player.pickStyle}</td>
                    </tr>
                `;
            }).join('');
        }

        function setupEventListeners() {
            document.getElementById('weekSelector').addEventListener('change', (e) => {
                currentWeek = parseInt(e.target.value);
                refreshAnalytics();
            });
        }

        async function refreshAnalytics() {
            console.log('🔄 GRID_ANALYTICS: Refreshing data...');
            showLoading(true);

            try {
                // Reset performance metrics
                performanceMetrics.loadStartTime = Date.now();
                performanceMetrics.cacheHits = 0;
                performanceMetrics.cacheMisses = 0;

                // Clear existing data
                allPicks = {};
                bibleData = {};
                gameIds = [];

                // Reload data
                await loadBibleData();
                await loadAllPicks();
                await generateAnalytics();

                console.log('✅ GRID_ANALYTICS: Data refreshed successfully');
            } catch (error) {
                console.error('❌ GRID_ANALYTICS: Refresh failed:', error);
                showError('Failed to refresh analytics data');
            } finally {
                showLoading(false);
            }
        }

        function switchAnalyticsMode(mode) {
            analyticsMode = mode;

            // Update button states
            document.querySelectorAll('#btnPerformance, #btnRisk, #btnTrends').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById('btn' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

            // Show/hide panels based on mode
            showAnalyticsPanels(mode);

            // Regenerate analytics for new mode
            generateAnalytics();
        }

        function showAnalyticsPanels(mode) {
            const panels = document.querySelectorAll('.analytics-panel');

            if (mode === 'performance') {
                // Show all panels for performance mode
                panels.forEach(panel => panel.style.display = 'block');
            } else if (mode === 'risk') {
                // Show only risk-related panels
                panels.forEach((panel, index) => {
                    const riskPanels = [4, 5, 7]; // Risk vs Reward, Game Difficulty, Upset Alert
                    panel.style.display = riskPanels.includes(index) ? 'block' : 'none';
                });
            } else if (mode === 'trends') {
                // Show only trend-related panels
                panels.forEach((panel, index) => {
                    const trendPanels = [1, 9, 10]; // Accuracy Trends, Momentum, Efficiency
                    panel.style.display = trendPanels.includes(index) ? 'block' : 'none';
                });
            }
        }

        let currentFilters = {
            player: 'all',
            gameStatus: 'all',
            confidence: 'all'
        };

        function applyFilters() {
            currentFilters.player = document.getElementById('playerFilter').value;
            currentFilters.gameStatus = document.getElementById('gameStatusFilter').value;
            currentFilters.confidence = document.getElementById('confidenceFilter').value;

            console.log('🔍 FILTERS: Applying filters:', currentFilters);

            // Regenerate analytics with filters
            generateAnalytics();
        }

        function getFilteredMemberIds() {
            let memberIds = Object.keys(poolMembers);

            if (currentFilters.player === 'tony') {
                memberIds = memberIds.filter(id =>
                    poolMembers[id]?.displayName?.toLowerCase().includes('tony')
                );
            } else if (currentFilters.player === 'top5' || currentFilters.player === 'bottom5') {
                // Calculate scores for ranking
                const scores = memberIds.map(memberId => {
                    const picks = allPicks[memberId];
                    let totalScore = 0;
                    if (picks) {
                        gameIds.forEach(gameId => {
                            const pick = picks[gameId];
                            const game = bibleData[gameId];
                            if (pick && game && game.status && game.status.type && game.status.type.completed) {
                                if (pick.winner && game.competitions && game.competitions[0]) {
                                    const competition = game.competitions[0];
                                    const actualWinner = competition.competitors.find(c => c.winner);
                                    if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                        totalScore += parseInt(pick.confidence) || 1;
                                    }
                                }
                            }
                        });
                    }
                    return { memberId, score: totalScore };
                }).sort((a, b) => b.score - a.score);

                if (currentFilters.player === 'top5') {
                    memberIds = scores.slice(0, 5).map(s => s.memberId);
                } else {
                    memberIds = scores.slice(-5).map(s => s.memberId);
                }
            }

            return memberIds;
        }

        function getFilteredGameIds() {
            let filteredGameIds = [...gameIds];

            if (currentFilters.gameStatus !== 'all') {
                filteredGameIds = gameIds.filter(gameId => {
                    const game = bibleData[gameId];
                    if (!game || !game.status || !game.status.type) return false;

                    switch (currentFilters.gameStatus) {
                        case 'completed':
                            return game.status.type.completed;
                        case 'live':
                            return !game.status.type.completed && game.status.type.description !== 'Scheduled';
                        case 'upcoming':
                            return game.status.type.description === 'Scheduled';
                        default:
                            return true;
                    }
                });
            }

            return filteredGameIds;
        }

        function shouldIncludePick(pick) {
            if (currentFilters.confidence === 'all') return true;

            const confidence = parseInt(pick.confidence) || 1;
            switch (currentFilters.confidence) {
                case 'high':
                    return confidence >= 12;
                case 'medium':
                    return confidence >= 7 && confidence <= 11;
                case 'low':
                    return confidence <= 6;
                default:
                    return true;
            }
        }

        let animationsEnabled = true;

        function toggleAnimations() {
            animationsEnabled = !animationsEnabled;
            const btn = document.getElementById('btnAnimations');

            if (animationsEnabled) {
                btn.classList.add('active');
                btn.textContent = '🎬 ANIMATE';
            } else {
                btn.classList.remove('active');
                btn.textContent = '⏸️ STATIC';
            }

            // Update chart animations
            Object.values(charts).forEach(chart => {
                if (chart && chart.options) {
                    chart.options.animation = animationsEnabled ? { duration: 1000 } : false;
                    chart.update();
                }
            });

            console.log('🎬 ANIMATIONS:', animationsEnabled ? 'ENABLED' : 'DISABLED');
        }

        function exportData() {
            const exportData = {
                timestamp: new Date().toISOString(),
                week: currentWeek,
                filters: currentFilters,
                analyticsMode: analyticsMode,
                playerCount: Object.keys(poolMembers).length,
                gameCount: gameIds.length,
                performance: performanceMetrics
            };

            // Create downloadable JSON file
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `nerd-grid-analytics-week-${currentWeek}-${Date.now()}.json`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('📤 EXPORT: Data exported successfully');
            alert('📊 Analytics data exported! Check your downloads folder.');
        }

        async function showCacheStatus() {
            const totalRequests = performanceMetrics.cacheHits + performanceMetrics.cacheMisses;
            const hitRate = totalRequests > 0 ? (performanceMetrics.cacheHits / totalRequests * 100).toFixed(1) : 100;
            const loadTime = Date.now() - performanceMetrics.loadStartTime;

            alert(`🚀 CACHE STATUS REPORT:\n\n` +
                  `• Cache Hit Rate: ${hitRate}%\n` +
                  `• Total Requests: ${totalRequests}\n` +
                  `• Load Time: ${loadTime}ms\n` +
                  `• Target: <500ms (Diamond Level)\n` +
                  `• Status: ${loadTime < 500 ? '✅ EXCELLENT' : '⚠️ NEEDS OPTIMIZATION'}`);
        }

        function showLoading(show) {
            const overlay = document.getElementById('loadingOverlay');
            overlay.style.display = show ? 'flex' : 'none';
        }

        function showError(message) {
            console.error('❌ GRID_ANALYTICS ERROR:', message);
            alert(`❌ Error: ${message}`);
        }

        // 🚀 SIMPLIFIED CSS-BASED CHARTS (NO EXTERNAL DEPENDENCIES)
        function generateCSSAccuracyTrends() {
            const container = document.getElementById('accuracyTrendsChart');
            const memberIds = getFilteredMemberIds().slice(0, 5); // Top 5 for readability

            let html = '<div style="color: #ffd700; font-weight: 700; margin-bottom: 15px;">Top Performers Accuracy</div>';

            memberIds.forEach(memberId => {
                const picks = allPicks[memberId];
                const name = poolMembers[memberId]?.displayName || 'Unknown';

                let totalPicks = 0;
                let correctPicks = 0;

                if (picks) {
                    gameIds.forEach(gameId => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && game && game.status && game.status.type && game.status.type.completed) {
                            totalPicks++;
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    correctPicks++;
                                }
                            }
                        }
                    });
                }

                const accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;

                html += `
                    <div class="chart-bar" style="width: ${accuracy}%; margin-bottom: 8px;">
                        <span class="chart-bar-label">${name}</span>
                        <span class="chart-bar-value">${accuracy.toFixed(1)}%</span>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function generateCSSPerformanceMatrix() {
            const container = document.getElementById('performanceMatrixChart');
            const memberIds = getFilteredMemberIds();

            const performanceData = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                const name = poolMembers[memberId]?.displayName || 'Unknown';

                let totalScore = 0;
                let accuracy = 0;
                let totalPicks = 0;
                let correctPicks = 0;

                if (picks) {
                    gameIds.forEach(gameId => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && game && game.status && game.status.type && game.status.type.completed) {
                            totalPicks++;
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    totalScore += parseInt(pick.confidence) || 1;
                                    correctPicks++;
                                }
                            }
                        }
                    });
                }

                accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;

                return { name, totalScore, accuracy, totalPicks };
            }).sort((a, b) => b.totalScore - a.totalScore).slice(0, 10);

            const maxScore = Math.max(...performanceData.map(p => p.totalScore)) || 1;

            let html = '<div style="color: #ffd700; font-weight: 700; margin-bottom: 15px;">Performance Leaders</div>';

            performanceData.forEach((player, index) => {
                const scorePercentage = (player.totalScore / maxScore) * 100;
                const rank = index + 1;

                html += `
                    <div style="margin-bottom: 12px; padding: 8px; background: rgba(0,255,65,0.1); border-radius: 4px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px;">
                            <span style="color: #00ff41; font-weight: 700;">#${rank} ${player.name}</span>
                            <span style="color: #ffd700;">${player.totalScore} pts</span>
                        </div>
                        <div class="chart-bar" style="width: ${scorePercentage}%; height: 12px;">
                            <span class="chart-bar-value" style="font-size: 10px;">${player.accuracy.toFixed(1)}% accuracy</span>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function generateCSSConfidenceStrategy() {
            const container = document.getElementById('confidenceStrategyChart');

            const confidenceLevels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];
            const successRates = confidenceLevels.map(confidence => {
                let total = 0;
                let correct = 0;

                Object.keys(poolMembers).forEach(memberId => {
                    const picks = allPicks[memberId];
                    if (!picks) return;

                    gameIds.forEach(gameId => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && pick.confidence == confidence && game && game.status && game.status.type && game.status.type.completed) {
                            total++;
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    correct++;
                                }
                            }
                        }
                    });
                });

                return { confidence, success: total > 0 ? (correct / total) * 100 : 0, total };
            });

            const maxSuccess = Math.max(...successRates.map(s => s.success)) || 1;

            let html = '<div style="color: #ffd700; font-weight: 700; margin-bottom: 15px;">Confidence Strategy Analysis</div>';

            successRates.forEach(level => {
                if (level.total > 0) {
                    const percentage = (level.success / maxSuccess) * 100;
                    html += `
                        <div class="chart-bar" style="width: ${percentage}%; margin-bottom: 6px; height: 16px;">
                            <span class="chart-bar-label">Conf ${level.confidence}</span>
                            <span class="chart-bar-value">${level.success.toFixed(1)}%</span>
                        </div>
                    `;
                }
            });

            container.innerHTML = html;
        }

        // Simplified versions for other charts
        function generateCSSRiskRewardMatrix() {
            const container = document.getElementById('riskRewardChart');
            container.innerHTML = '<div style="color: #00ff41; text-align: center; margin-top: 50px;">📊 Risk analysis requires Chart.js<br><button class="terminal-button mt-4" onclick="location.reload()">🔄 RETRY</button></div>';
        }

        function generateCSSGameDifficultyHeatMap() {
            const container = document.getElementById('gameDifficultyChart');
            container.innerHTML = '<div style="color: #00ff41; text-align: center; margin-top: 50px;">🌡️ Heat map requires Chart.js<br><button class="terminal-button mt-4" onclick="location.reload()">🔄 RETRY</button></div>';
        }

        function generateCSSTonyRadarChart() {
            const container = document.getElementById('tonyRadarChart');

            // Find Tony's user ID - check multiple variations
            const tonyId = Object.keys(poolMembers).find(id => {
                const displayName = poolMembers[id]?.displayName?.toLowerCase() || '';
                return displayName.includes('tony') || displayName.includes('weeg') || displayName.includes('anthony');
            });

            if (!tonyId || !allPicks[tonyId]) {
                // Show available users for debugging
                const availableUsers = Object.keys(poolMembers).map(id =>
                    poolMembers[id]?.displayName || 'Unknown'
                ).slice(0, 5).join(', ');

                container.innerHTML = `
                    <div style="color: #888; text-align: center; margin-top: 30px;">
                        Tony not found in current data<br>
                        <small style="color: #666; margin-top: 10px; display: block;">
                            Available users: ${availableUsers}...
                        </small>
                        <div style="color: #00ff41; margin-top: 15px;">
                            📊 Showing pool leader instead
                        </div>
                    </div>
                `;

                // Show top performer instead
                const memberIds = getFilteredMemberIds();
                if (memberIds.length > 0) {
                    showTopPerformerRadar(container, memberIds[0]);
                }
                return;
            }

            const picks = allPicks[tonyId];
            let totalPicks = 0;
            let correctPicks = 0;
            let totalScore = 0;

            gameIds.forEach(gameId => {
                const pick = picks[gameId];
                const game = bibleData[gameId];
                if (pick && game && game.status && game.status.type && game.status.type.completed) {
                    totalPicks++;
                    if (pick.winner && game.competitions && game.competitions[0]) {
                        const competition = game.competitions[0];
                        const actualWinner = competition.competitors.find(c => c.winner);
                        if (actualWinner && actualWinner.team.displayName === pick.winner) {
                            correctPicks++;
                            totalScore += parseInt(pick.confidence) || 1;
                        }
                    }
                }
            });

            const accuracy = totalPicks > 0 ? (correctPicks / totalPicks) * 100 : 0;

            let html = `
                <div style="color: #00ced1; font-weight: 700; margin-bottom: 15px;">Tony's Performance Metrics</div>
                <div style="color: #00ff41; line-height: 1.8;">
                    🎯 <strong>Accuracy:</strong> ${accuracy.toFixed(1)}%<br>
                    📊 <strong>Total Score:</strong> ${totalScore} points<br>
                    🎮 <strong>Games Played:</strong> ${totalPicks}<br>
                    ✅ <strong>Correct Picks:</strong> ${correctPicks}<br>
                    ⭐ <strong>Performance:</strong> ${accuracy > 60 ? 'Excellent' : accuracy > 50 ? 'Good' : 'Needs Improvement'}
                </div>
            `;

            container.innerHTML = html;
        }

        function generateCSSUpsetAlertSystem() {
            const container = document.getElementById('upsetAlertChart');
            container.innerHTML = '<div style="color: #00ff41; text-align: center; margin-top: 50px;">🚨 Upset alerts require Chart.js<br><button class="terminal-button mt-4" onclick="location.reload()">🔄 RETRY</button></div>';
        }

        function generateCSSMomentumAnalyzer() {
            const container = document.getElementById('momentumChart');
            container.innerHTML = '<div style="color: #00ff41; text-align: center; margin-top: 50px;">📈 Momentum charts require Chart.js<br><button class="terminal-button mt-4" onclick="location.reload()">🔄 RETRY</button></div>';
        }

        function generateCSSEfficiencyMatrix() {
            const container = document.getElementById('efficiencyChart');
            container.innerHTML = '<div style="color: #00ff41; text-align: center; margin-top: 50px;">⚙️ Efficiency matrix requires Chart.js<br><button class="terminal-button mt-4" onclick="location.reload()">🔄 RETRY</button></div>';
        }

        function showChartError() {
            showLoading(false);

            // Try to load basic data first
            Promise.all([loadPoolMembers(), loadBibleData(), loadAllPicks()])
                .then(() => {
                    updateQuickStats();
                    generatePerformanceTable();
                    generateTextBasedAnalytics();
                })
                .catch(() => {
                    showBasicError();
                });
        }

        function generateTextBasedAnalytics() {
            const analyticsGrids = document.querySelectorAll('.analytics-grid');
            analyticsGrids.forEach(grid => {
                grid.innerHTML = `
                    <div class="analytics-panel">
                        <div class="panel-title">📊 TEXT-BASED ANALYTICS</div>
                        <div class="p-6">
                            <div style="color: #ffd700; font-size: 16px; margin-bottom: 15px;">
                                📈 Charts unavailable - showing text analytics
                            </div>
                            <div id="textAnalytics" style="color: #00ff41; line-height: 1.6;">
                                Loading analytics data...
                            </div>
                            <div class="mt-4">
                                <button class="terminal-button" onclick="location.reload()">
                                    🔄 RETRY CHARTS
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            });

            // Generate text-based insights
            const memberIds = Object.keys(poolMembers);
            const insights = [];

            // Calculate basic stats
            const scores = memberIds.map(memberId => {
                const picks = allPicks[memberId];
                let score = 0;
                if (picks) {
                    gameIds.forEach(gameId => {
                        const pick = picks[gameId];
                        const game = bibleData[gameId];
                        if (pick && game && game.status && game.status.type && game.status.type.completed) {
                            if (pick.winner && game.competitions && game.competitions[0]) {
                                const competition = game.competitions[0];
                                const actualWinner = competition.competitors.find(c => c.winner);
                                if (actualWinner && actualWinner.team.displayName === pick.winner) {
                                    score += parseInt(pick.confidence) || 1;
                                }
                            }
                        }
                    });
                }
                return { name: poolMembers[memberId]?.displayName || 'Unknown', score };
            }).sort((a, b) => b.score - a.score);

            if (scores.length > 0) {
                insights.push(`🏆 CURRENT LEADER: ${scores[0].name} (${scores[0].score} points)`);
                insights.push(`📊 TOTAL PLAYERS: ${scores.length}`);
                insights.push(`🎯 AVERAGE SCORE: ${(scores.reduce((sum, s) => sum + s.score, 0) / scores.length).toFixed(1)}`);
                insights.push(`📈 SCORE RANGE: ${scores[scores.length - 1].score} - ${scores[0].score} points`);

                if (scores.length >= 3) {
                    insights.push(`🥉 TOP 3 PERFORMERS:`);
                    insights.push(`   1. ${scores[0].name}: ${scores[0].score} pts`);
                    insights.push(`   2. ${scores[1].name}: ${scores[1].score} pts`);
                    insights.push(`   3. ${scores[2].name}: ${scores[2].score} pts`);
                }
            }

            const textAnalytics = document.getElementById('textAnalytics');
            if (textAnalytics) {
                textAnalytics.innerHTML = insights.join('<br>');
            }
        }

        function showBasicError() {
            const analyticsGrids = document.querySelectorAll('.analytics-grid');
            analyticsGrids.forEach(grid => {
                grid.innerHTML = `
                    <div class="analytics-panel">
                        <div class="panel-title">❌ ANALYTICS ERROR</div>
                        <div class="p-6 text-center">
                            <div style="color: #ff6b6b; font-size: 18px; margin-bottom: 20px;">
                                📊 Analytics temporarily unavailable
                            </div>
                            <div style="color: #888; margin-bottom: 20px;">
                                Unable to load analytics data.<br>
                                Please check your connection and try again.
                            </div>
                            <button class="terminal-button" onclick="location.reload()">
                                🔄 RETRY LOADING
                            </button>
                        </div>
                    </div>
                `;
            });
        }

        // 🚀 INITIALIZE ON LOAD (NO CHART.JS DEPENDENCIES)
        window.addEventListener('load', () => {
            console.log('📊 GRID_ANALYTICS: Starting CSS-based initialization...');
            initialize();
        });

        // Export functions for global access
        window.refreshAnalytics = refreshAnalytics;
        window.switchAnalyticsMode = switchAnalyticsMode;
        window.showCacheStatus = showCacheStatus;
    </script>
</body>
</html>