<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Season Picks Viewer - All Users (Authenticated)</title>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 p-8">
    <div class="max-w-7xl mx-auto">
        <h1 class="text-3xl font-bold mb-6">üèÜ Season 2025 Picks - All Users (Season Totals)</h1>

        <div class="mb-4 flex flex-wrap items-center gap-4">
            <div class="flex items-center gap-2">
                <button id="signIn" class="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700">
                    Sign In with Google
                </button>
                <button id="loadPicks" class="bg-blue-600 text-white px-4 py-2 rounded hover:bg-blue-700 disabled:bg-gray-400" disabled>
                    Load Season Totals
                </button>
                <button id="generateMissing" class="bg-red-600 text-white px-4 py-2 rounded hover:bg-red-700 disabled:bg-gray-400 ml-2" disabled>
                    Generate Missing Week 3 Picks
                </button>
            </div>

            <div class="flex items-center gap-2">
                <div class="px-4 py-2 bg-purple-100 border border-purple-300 rounded text-purple-800 font-semibold">
                    üìä 2025 NFL Season (Weeks 1-18)
                </div>
            </div>

            <span id="status" class="text-gray-600"></span>
        </div>

        <div id="authInfo" class="mb-4 p-3 bg-blue-50 border border-blue-200 rounded hidden">
            <p id="userInfo" class="text-blue-800"></p>
        </div>

        <div id="picksContainer" class="space-y-6"></div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js';
        import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js';
        import { getFirestore, collection, getDocs, doc, getDoc, writeBatch } from 'https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js';

        // Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyDAF1MbAhL2uPIVUGMDlXvCqtknUUCX5Gw",
            authDomain: "nerdfootball.firebaseapp.com",
            databaseURL: "https://nerdfootball-default-rtdb.firebaseio.com",
            projectId: "nerdfootball",
            storageBucket: "nerdfootball.appspot.com",
            messagingSenderId: "969304790725",
            appId: "1:969304790725:web:892df38db0b0e62bde02ac"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const provider = new GoogleAuthProvider();

        let currentUser = null;

        // Admin UIDs (add your UID here)
        const ADMIN_UIDS = [
            'WxSPmEildJdqs6T5hIpBUZrscwt2',
            'BPQvRhpVl1ZzsBXaS7C2iFe2Xpc2',
            'bEVzcZtSExT8cIjamWnGbWZ3J5s1'
        ];

        // Auth state listener
        onAuthStateChanged(auth, async (user) => {
            if (user) {
                currentUser = user;
                document.getElementById('userInfo').textContent = `Signed in as: ${user.email} (${user.uid})`;
                document.getElementById('authInfo').classList.remove('hidden');
                document.getElementById('signIn').textContent = 'Signed In';
                document.getElementById('signIn').disabled = true;

                // Check if user is registered in NerdFootball system
                document.getElementById('status').textContent = 'Checking user registration...';
                const isRegistered = await checkUserRegistration(user.uid);

                if (isRegistered) {
                    document.getElementById('loadPicks').disabled = false;
                    document.getElementById('generateMissing').disabled = false;
                    document.getElementById('status').textContent = 'Ready to load picks';
                } else {
                    document.getElementById('loadPicks').disabled = true;
                    document.getElementById('status').textContent = 'Access denied: Not a registered NerdFootball user';
                }
            } else {
                currentUser = null;
                document.getElementById('authInfo').classList.add('hidden');
                document.getElementById('signIn').textContent = 'Sign In with Google';
                document.getElementById('signIn').disabled = false;
                document.getElementById('loadPicks').disabled = true;
                document.getElementById('generateMissing').disabled = true;
                document.getElementById('status').textContent = 'Please sign in';
            }
        });

        document.getElementById('signIn').addEventListener('click', async () => {
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                document.getElementById('status').textContent = `Sign in error: ${error.message}`;
            }
        });

        // Event listeners
        document.getElementById('loadPicks').addEventListener('click', loadSeasonPicks);
        document.getElementById('generateMissing').addEventListener('click', generateMissingPicks);


        function getCurrentWeekNumber() {
            // Week 1 started Sept 4, 2025 - calculate current week based on date
            const week1Start = new Date('2025-09-04');
            const today = new Date();
            const diffTime = today - week1Start;
            const diffWeeks = Math.floor(diffTime / (1000 * 60 * 60 * 24 * 7)) + 1;
            return Math.max(1, Math.min(18, diffWeeks));
        }

        async function checkUserRegistration(uid) {
            try {
                // Check if user exists in the NerdFootball users collection
                const userPath = `artifacts/nerdfootball/public/data/nerdfootball_users/${uid}`;
                const userSnap = await getDoc(doc(db, userPath));

                if (userSnap.exists()) {
                    console.log(`‚úÖ User ${uid} is registered in NerdFootball`);
                    return true;
                } else {
                    console.log(`‚ùå User ${uid} not found in NerdFootball users`);
                    return false;
                }
            } catch (error) {
                console.error('Error checking user registration:', error);
                return false;
            }
        }

        async function loadBibleData(weekNumber) {
            console.log(`üîç Loading Week ${weekNumber} bible data from Firestore...`);

            try {
                // Load from Firestore (single source of truth)
                const gamesRef = doc(db, `artifacts/nerdfootball/public/data/nerdfootball_games/${weekNumber}`);
                const gamesSnap = await getDoc(gamesRef);

                if (!gamesSnap.exists()) {
                    console.warn(`No games found for Week ${weekNumber} in Firestore`);
                    return null;
                }

                const bibleData = gamesSnap.data();
                console.log(`‚úÖ Loaded Week ${weekNumber} bible data:`, Object.keys(bibleData).filter(k => k !== '_metadata').length, 'games');

                return bibleData;
            } catch (error) {
                console.error(`‚ùå Error loading Week ${weekNumber} bible data from Firestore:`, error);
                return null;
            }
        }

        async function loadSeasonPicks() {
            if (!currentUser) {
                document.getElementById('status').textContent = 'Please sign in first';
                return;
            }

            // Double-check user registration
            const isRegistered = await checkUserRegistration(currentUser.uid);
            if (!isRegistered) {
                document.getElementById('status').textContent = 'Access denied: Not a registered NerdFootball user';
                return;
            }

            const status = document.getElementById('status');
            const container = document.getElementById('picksContainer');

            status.textContent = 'Loading season data (all weeks)...';
            container.innerHTML = '';

            try {
                // Load pool members for validation
                let poolMembers = {};
                try {
                    const membersPath = 'artifacts/nerdfootball/pools/nerduniverse-2025/metadata/members';
                    const membersSnap = await getDoc(doc(db, membersPath));
                    if (membersSnap.exists()) {
                        poolMembers = membersSnap.data();
                    }
                } catch (e) {
                    console.warn('Could not load pool members:', e);
                }

                // Batch load all user names in one query (MUCH FASTER!)
                status.textContent = 'Loading all user data...';
                const userNames = {};
                const userEmails = {};

                try {
                    const usersCollection = collection(db, 'artifacts/nerdfootball/public/data/nerdfootball_users');
                    const usersSnap = await getDocs(usersCollection);

                    usersSnap.forEach(userDoc => {
                        const userData = userDoc.data();
                        userNames[userDoc.id] = userData.userName || userData.displayName || userData.name || 'Unknown User';
                        userEmails[userDoc.id] = userData.email || userData.emailAddress || 'No Email';
                    });

                    console.log(`‚úÖ Loaded ${usersSnap.size} total users in batch`);
                } catch (e) {
                    console.warn('Could not batch load users:', e);
                }

                // Initialize season totals for all users
                const seasonTotals = {};
                const actualCurrentWeek = getCurrentWeekNumber();

                // Process each week (1-18)
                for (let weekNumber = 1; weekNumber <= 18; weekNumber++) {
                    status.textContent = `Processing Week ${weekNumber}...`;

                    try {
                        // Load bible data for this week
                        const bibleData = await loadBibleData(weekNumber);
                        if (!bibleData) {
                            console.warn(`No bible data for Week ${weekNumber}, skipping...`);
                            continue;
                        }

                        // Load picks for this week
                        const picksPath = `artifacts/nerdfootball/public/data/nerdfootball_picks/${weekNumber}/submissions`;
                        const picksCollection = collection(db, picksPath);
                        const picksSnap = await getDocs(picksCollection);

                        if (picksSnap.size === 0) {
                            console.warn(`No picks for Week ${weekNumber}, skipping...`);
                            continue;
                        }

                        // Process each user's picks for this week
                        picksSnap.forEach(userDoc => {
                            const userId = userDoc.id;
                            const picks = userDoc.data();

                            // Initialize user if not exists
                            if (!seasonTotals[userId]) {
                                seasonTotals[userId] = {
                                    userId,
                                    userName: userNames[userId] || 'Unknown',
                                    userEmail: userEmails[userId] || 'No Email',
                                    isPoolMember: !!poolMembers[userId],
                                    totalPointsEarned: 0,
                                    totalCorrectPicks: 0,
                                    totalValidPicks: 0,
                                    weeklyBreakdown: {},
                                    winningPicks: []
                                };
                            }

                            // Analyze picks for this week
                            const analysis = analyzePicks(picks, bibleData);

                            // Add to season totals
                            seasonTotals[userId].totalPointsEarned += analysis.totalPointsEarned;
                            seasonTotals[userId].totalCorrectPicks += analysis.correctPicks;
                            seasonTotals[userId].totalValidPicks += analysis.totalValidPicks;

                            // Store weekly breakdown
                            seasonTotals[userId].weeklyBreakdown[weekNumber] = {
                                pointsEarned: analysis.totalPointsEarned,
                                correctPicks: analysis.correctPicks,
                                totalPicks: analysis.totalValidPicks
                            };

                            // Add winning picks with week context
                            if (analysis.winningPicks && analysis.winningPicks.length > 0) {
                                analysis.winningPicks.forEach(pick => {
                                    seasonTotals[userId].winningPicks.push({
                                        ...pick,
                                        week: weekNumber
                                    });
                                });
                            }
                        });

                    } catch (error) {
                        console.warn(`Error processing Week ${weekNumber}:`, error);
                    }
                }

                // Convert to array and sort by total points
                const seasonData = Object.values(seasonTotals)
                    .filter(user => user.totalValidPicks > 0) // Only users with picks
                    .sort((a, b) => b.totalPointsEarned - a.totalPointsEarned);

                status.textContent = `‚úÖ Loaded season totals for ${seasonData.length} users`;
                displaySeasonTotals(seasonData, actualCurrentWeek);

            } catch (error) {
                status.textContent = `Error: ${error.message}`;
                console.error('Error loading season picks:', error);
            }
        }

        function displaySeasonTotals(seasonData, actualCurrentWeek) {
            const container = document.getElementById('picksContainer');

            // Create and display season leaderboard
            const leaderboardDiv = document.createElement('div');
            leaderboardDiv.className = 'bg-gradient-to-r from-purple-100 to-blue-100 rounded-lg shadow-lg p-6 mb-6';

            const leaderboardHTML = `
                <h2 class="text-2xl font-bold text-center mb-4 text-purple-800">üèÜ 2025 Season Leaderboard</h2>
                <div class="text-center mb-4 text-sm text-gray-600">
                    Through Week ${actualCurrentWeek - 1} ‚Ä¢ Updated: ${new Date().toLocaleDateString()}
                </div>
                <div class="grid gap-2">
                    ${seasonData.map((user, index) => {
                        const isTopThree = index < 3;
                        const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : '';
                        const bgClass = isTopThree ? 'bg-white border-2 border-yellow-300' : 'bg-white border border-gray-200';

                        // Calculate accuracy percentage
                        const accuracyPercent = user.totalValidPicks > 0 ?
                            ((user.totalCorrectPicks / user.totalValidPicks) * 100).toFixed(1) : '0.0';

                        // Get weeks played
                        const weeksPlayed = Object.keys(user.weeklyBreakdown).length;

                        return `
                            <div class="${bgClass} rounded-lg p-3 flex justify-between items-center">
                                <div class="flex items-center gap-3">
                                    <span class="text-lg font-bold ${isTopThree ? 'text-purple-600' : 'text-gray-600'}">${medal || (index + 1)}</span>
                                    <div>
                                        <div class="font-semibold ${user.isPoolMember ? 'text-green-700' : 'text-red-500'}">${user.userName}</div>
                                        <div class="text-xs text-gray-500 font-mono">${user.userId}</div>
                                        <div class="text-xs text-blue-600">${user.userEmail}</div>
                                        <div class="text-xs text-gray-600">
                                            ${weeksPlayed} weeks played ‚Ä¢ ${accuracyPercent}% accuracy
                                        </div>
                                    </div>
                                    ${!user.isPoolMember ? '<span class="text-xs bg-red-100 text-red-600 px-2 py-1 rounded">Not Pool Member</span>' : ''}
                                </div>
                                <div class="text-right">
                                    <div class="text-lg font-bold text-purple-600">${user.totalPointsEarned} pts</div>
                                    <div class="text-xs text-gray-600">${user.totalCorrectPicks}/${user.totalValidPicks} correct</div>
                                    <div class="text-xs text-blue-600">${user.winningPicks.length} winning picks</div>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                <p class="text-center text-sm text-gray-600 mt-3">Showing all ${seasonData.length} users with picks</p>
            `;

            leaderboardDiv.innerHTML = leaderboardHTML;
            container.appendChild(leaderboardDiv);

            // Display detailed season breakdown for each user
            seasonData.forEach((user, index) => {
                const userDiv = document.createElement('div');
                userDiv.className = `bg-white rounded-lg shadow p-6 ${user.isPoolMember ? 'border-l-4 border-green-500' : 'border-l-4 border-red-500'}`;

                // Calculate weeks played and average points per week
                const weeksPlayed = Object.keys(user.weeklyBreakdown).length;
                const avgPointsPerWeek = weeksPlayed > 0 ? (user.totalPointsEarned / weeksPlayed).toFixed(1) : '0.0';
                const accuracyPercent = user.totalValidPicks > 0 ?
                    ((user.totalCorrectPicks / user.totalValidPicks) * 100).toFixed(1) : '0.0';

                // Get top winning picks (highest point values)
                const topWinningPicks = user.winningPicks
                    .sort((a, b) => b.points - a.points)
                    .slice(0, 5);

                userDiv.innerHTML = `
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <h3 class="text-lg font-semibold">${index + 1}. ${user.userName}</h3>
                            <p class="text-xs text-gray-500 font-mono mb-1">${user.userId}</p>
                            <p class="text-xs text-blue-600 mb-1">${user.userEmail}</p>
                            <p class="text-sm ${user.isPoolMember ? 'text-green-600' : 'text-red-600'}">
                                ${user.isPoolMember ? '‚úÖ Pool Member' : '‚ùå Not Pool Member'}
                            </p>
                        </div>
                        <div class="text-right">
                            <p class="text-lg font-bold text-purple-600">üèÜ ${user.totalPointsEarned} Total Points</p>
                            <p class="text-sm text-blue-600">‚úÖ ${user.totalCorrectPicks}/${user.totalValidPicks} correct (${accuracyPercent}%)</p>
                            <p class="text-sm text-gray-600">üìä ${weeksPlayed} weeks ‚Ä¢ ${avgPointsPerWeek} pts/week avg</p>
                            <p class="text-sm text-green-600">üéØ ${user.winningPicks.length} winning picks</p>
                        </div>
                    </div>

                    ${topWinningPicks.length > 0 ? `
                        <div class="mb-4 p-3 bg-green-50 border border-green-200 rounded">
                            <h4 class="text-sm font-semibold text-green-800 mb-2">‚úÖ Top Winning Picks</h4>
                            <p class="text-xs text-green-700">
                                ${topWinningPicks.map(pick => `W${pick.week}: ${pick.team} (${pick.points}pts)`).join(' ‚Ä¢ ')}
                            </p>
                        </div>
                    ` : ''}

                    <div class="mb-4 p-3 bg-gray-50 border border-gray-200 rounded">
                        <h4 class="text-sm font-semibold text-gray-800 mb-2">üìà Weekly Points Totals</h4>
                        <div class="grid grid-cols-6 md:grid-cols-9 gap-1 text-xs">
                            ${Array.from({length: 18}, (_, i) => i + 1).map(week => {
                                const weekData = user.weeklyBreakdown[week];
                                if (!weekData) {
                                    return `
                                        <div class="bg-gray-100 p-1 rounded text-center border-2 border-dashed border-gray-300">
                                            <div class="font-semibold text-gray-400">W${week}</div>
                                            <div class="text-gray-400">--</div>
                                            <div class="text-gray-400">no picks</div>
                                        </div>
                                    `;
                                }

                                const bgColor = weekData.pointsEarned > 50 ? 'bg-green-200' :
                                               weekData.pointsEarned > 30 ? 'bg-yellow-200' : 'bg-red-200';
                                const textColor = weekData.pointsEarned > 50 ? 'text-green-800' :
                                                 weekData.pointsEarned > 30 ? 'text-yellow-800' : 'text-red-800';

                                return `
                                    <div class="${bgColor} p-1 rounded text-center border">
                                        <div class="font-semibold ${textColor}">W${week}</div>
                                        <div class="font-bold ${textColor}">${weekData.pointsEarned}</div>
                                        <div class="${textColor}">${weekData.correctPicks}/${weekData.totalPicks}</div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        <div class="mt-2 text-xs text-gray-600 flex justify-between">
                            <span>üü¢ 50+ pts ‚Ä¢ üü° 30-50 pts ‚Ä¢ üî¥ &lt;30 pts</span>
                            <span>Total: <strong>${user.totalPointsEarned} points</strong></span>
                        </div>
                    </div>

                    <details class="mt-4">
                        <summary class="cursor-pointer text-sm text-blue-600 hover:text-blue-800">View Season Details</summary>
                        <pre class="mt-2 p-3 bg-gray-100 rounded text-xs overflow-x-auto">${JSON.stringify({
                            totalPoints: user.totalPointsEarned,
                            accuracy: accuracyPercent + '%',
                            weeklyBreakdown: user.weeklyBreakdown,
                            allWinningPicks: user.winningPicks
                        }, null, 2)}</pre>
                    </details>
                `;

                container.appendChild(userDiv);
            });
        }

        function analyzePicks(picks, bibleData) {
            const issues = [];
            const gameIds = Object.keys(picks).filter(key => !['userName', 'submittedAt', 'weekNumber', 'timestamp', 'mondayNightPoints', 'mnfTotalPoints', 'tiebreaker', 'totalPoints', 'userId', 'lastUpdated', 'poolId', 'survivorPick', 'createdAt', 'week', 'games'].includes(key));

            // All weeks now use consistent Firestore structure
            const expectedGameIds = bibleData ? Object.keys(bibleData).filter(k => k !== '_metadata') : [];
            const expectedGameCount = expectedGameIds.length;

            // Check for expected game IDs
            const missingGames = expectedGameIds.filter(id => !gameIds.includes(id));
            const extraGames = gameIds.filter(id => !expectedGameIds.includes(id));

            if (missingGames.length > 0) {
                issues.push(`Missing games: ${missingGames.join(', ')}`);
            }
            if (extraGames.length > 0) {
                issues.push(`Extra games: ${extraGames.join(', ')}`);
            }

            // Check confidence values and calculate accuracy
            const confidenceValues = [];
            let correctPicks = 0;
            let totalValidPicks = 0;
            let totalPointsEarned = 0;
            const pickResults = {};
            const winningPicks = []; // Track winning picks with team names and points

            gameIds.forEach(gameId => {
                const pick = picks[gameId];
                if (pick && typeof pick === 'object') {
                    if (pick.winner === '[object Object]' || typeof pick.winner === 'object') {
                        issues.push(`Game ${gameId}: Winner corrupted`);
                        pickResults[gameId] = { isValid: false, isCorrect: false };
                    } else if (pick.winner && bibleData && bibleData[gameId]) {
                        // Compare user pick with bible result
                        const actualWinner = bibleData[gameId].winner;
                        const userPick = pick.winner;
                        const isCorrect = actualWinner === userPick;

                        pickResults[gameId] = {
                            isValid: true,
                            isCorrect: isCorrect,
                            userPick: userPick,
                            actualWinner: actualWinner
                        };

                        totalValidPicks++;
                        if (isCorrect) {
                            correctPicks++;
                            // Add confidence points for correct picks
                            if (typeof pick.confidence === 'number' && pick.confidence >= 1 && pick.confidence <= expectedGameCount) {
                                totalPointsEarned += pick.confidence;

                                // Store winning pick with validation
                                if (typeof userPick === 'string' && userPick.length > 0 && userPick !== '[object Object]') {
                                    winningPicks.push({
                                        team: userPick,
                                        points: pick.confidence,
                                        gameId: gameId
                                    });
                                }
                            }
                        }
                    } else {
                        pickResults[gameId] = { isValid: false, isCorrect: false };
                    }

                    if (pick.confidence !== undefined) {
                        if (typeof pick.confidence !== 'number' || pick.confidence < 1 || pick.confidence > expectedGameCount) {
                            issues.push(`Game ${gameId}: Invalid confidence ${pick.confidence} (should be 1-${expectedGameCount})`);
                        } else {
                            confidenceValues.push(pick.confidence);
                        }
                    } else {
                        issues.push(`Game ${gameId}: Missing confidence`);
                    }
                }
            });

            // Check for duplicate confidence values
            const uniqueConfidence = [...new Set(confidenceValues)];
            if (confidenceValues.length !== uniqueConfidence.length) {
                const duplicates = confidenceValues.filter((val, idx) => confidenceValues.indexOf(val) !== idx);
                issues.push(`Duplicate confidence: ${[...new Set(duplicates)].join(', ')}`);
            }

            // Calculate losing points total and validate sum
            let totalLosingPoints = 0;
            Object.keys(pickResults).forEach(gameId => {
                const result = pickResults[gameId];
                const pick = picks[gameId];
                if (result.isValid && !result.isCorrect && pick && typeof pick.confidence === 'number') {
                    totalLosingPoints += pick.confidence;
                }
            });

            // Expected total confidence points: 1+2+3+...+n = n√ó(n+1)/2
            const expectedTotal = expectedGameCount * (expectedGameCount + 1) / 2;
            const actualTotal = totalPointsEarned + totalLosingPoints;
            const isSumValid = actualTotal === expectedTotal;

            return {
                totalGames: gameIds.length,
                issues,
                confidenceValues: confidenceValues.sort((a, b) => a - b),
                gameIds,
                correctPicks,
                totalValidPicks,
                totalPointsEarned,
                totalLosingPoints,
                expectedTotal,
                actualTotal,
                isSumValid,
                pickResults,
                winningPicks: winningPicks.sort((a, b) => b.points - a.points) // Sort by points descending
            };
        }

        function generatePicksGrid(picks, analysis, bibleData) {
            // Use expected game IDs from bible data, or fallback to current week calculation
            const expectedGameIds = bibleData ? Object.keys(bibleData).filter(k => k !== '_metadata').sort() :
                                   Array.from({length: 16}, (_, i) => (currentWeek * 100 + 1 + i).toString());

            return expectedGameIds.map(gameId => {
                const pick = picks[gameId];
                if (!pick) {
                    return `<div class="p-2 bg-red-100 border border-red-300 rounded">
                        <div class="font-semibold text-red-800">${gameId}</div>
                        <div class="text-red-600">MISSING</div>
                    </div>`;
                }

                const isCorrupted = pick.winner === '[object Object]' || typeof pick.winner === 'object';
                const isInvalidConfidence = typeof pick.confidence !== 'number' || pick.confidence < 1 || pick.confidence > 16;
                const pickResult = analysis.pickResults[gameId];

                let bgColor, textColor, resultIcon = '';

                if (isCorrupted || isInvalidConfidence) {
                    bgColor = 'bg-red-100 border-red-300';
                    textColor = 'text-red-800';
                } else if (pickResult && pickResult.isValid) {
                    if (pickResult.isCorrect) {
                        bgColor = 'bg-green-200 border-green-400';
                        textColor = 'text-green-900';
                        resultIcon = '‚úÖ';
                    } else {
                        bgColor = 'bg-orange-100 border-orange-300';
                        textColor = 'text-orange-800';
                        resultIcon = '‚ùå';
                    }
                } else {
                    bgColor = 'bg-gray-100 border-gray-300';
                    textColor = 'text-gray-800';
                }

                return `<div class="p-2 ${bgColor} border rounded">
                    <div class="font-semibold ${textColor}">${gameId} ${resultIcon}</div>
                    <div class="text-xs ${textColor}">C: ${pick.confidence || 'N/A'}</div>
                    <div class="text-xs ${textColor} truncate" title="${pick.winner || 'N/A'}">
                        ${isCorrupted ? '[CORRUPT]' : (pick.winner || 'N/A').substring(0, 8)}
                    </div>
                    ${pickResult && pickResult.isValid && !pickResult.isCorrect ?
                        `<div class="text-xs ${textColor} opacity-75" title="Actual winner">‚Üí ${(pickResult.actualWinner || '').substring(0, 8)}</div>` : ''}
                </div>`;
            }).join('');
        }

        async function generateMissingPicks() {
            // SAFETY CHECK 1: Only works for Week 3
            if (currentWeek !== 3) {
                alert('üö® SAFETY: This function only works for Week 3');
                return;
            }

            // SAFETY CHECK 2: Must be authenticated
            if (!currentUser) {
                alert('üö® SAFETY: Please sign in first');
                return;
            }

            // SAFETY CHECK 3: Confirm action
            const confirmed = confirm('‚ö†Ô∏è GENERATE MISSING WEEK 3 PICKS?\n\nThis will ONLY create picks for users who have NO Week 3 picks document.\nExisting picks will NEVER be touched.\n\nContinue?');
            if (!confirmed) return;

            const status = document.getElementById('status');
            status.textContent = 'üîç Analyzing missing Week 3 picks...';

            try {
                // Step 1: Get pool members
                const poolMembersPath = 'artifacts/nerdfootball/pools/nerduniverse-2025/metadata/members';
                const poolMembersSnap = await getDoc(doc(db, poolMembersPath));
                const poolMembers = poolMembersSnap.exists() ? poolMembersSnap.data() : {};
                const poolMemberIds = Object.keys(poolMembers);

                // Step 2: Get existing Week 3 picks documents
                const picksPath = 'artifacts/nerdfootball/public/data/nerdfootball_picks/3/submissions';
                const picksSnap = await getDocs(collection(db, picksPath));
                const existingPickIds = [];
                picksSnap.forEach(doc => existingPickIds.push(doc.id));

                // Step 3: Find users with NO picks document (SAFE FILTER)
                const missingUsers = poolMemberIds.filter(uid => !existingPickIds.includes(uid));

                console.log('üîç SAFETY ANALYSIS:');
                console.log('Pool members total:', poolMemberIds.length);
                console.log('Existing picks documents:', existingPickIds.length);
                console.log('Missing users (NO document):', missingUsers.length);
                console.log('Missing user IDs:', missingUsers);

                // SAFETY CHECK 4: No missing users
                if (missingUsers.length === 0) {
                    status.textContent = '‚úÖ SAFE: No missing users found - all have picks documents!';
                    return;
                }

                // SAFETY CHECK 5: Final confirmation with exact numbers
                const finalConfirm = confirm(`üîç FINAL SAFETY CHECK:\n\n‚Ä¢ Pool Members: ${poolMemberIds.length}\n‚Ä¢ Have Picks: ${existingPickIds.length}\n‚Ä¢ Missing: ${missingUsers.length}\n\nGenerate DEFAULT picks for ${missingUsers.length} missing users?\n(All home teams, confidence 1-16)\n\nEXISTING PICKS WILL NOT BE TOUCHED!`);
                if (!finalConfirm) {
                    status.textContent = 'Cancelled by user';
                    return;
                }

                status.textContent = 'üìö Loading Week 3 bible data...';

                // Step 4: Load Week 3 bible data for home teams
                const bibleData = await loadBibleData();
                const gameIds = Object.keys(bibleData).filter(k => k !== '_metadata').sort();

                if (gameIds.length !== 16) {
                    throw new Error(`Expected 16 games, found ${gameIds.length}`);
                }

                status.textContent = `üèóÔ∏è Creating ${missingUsers.length} missing pick documents...`;

                // Step 5: Generate default picks (ONLY for missing users)
                const batch = writeBatch(db);
                let generatedCount = 0;

                for (const userId of missingUsers) {
                    // SAFETY: Double-check this user has no document
                    const userPicksRef = doc(db, picksPath, userId);
                    const existingDoc = await getDoc(userPicksRef);

                    if (existingDoc.exists()) {
                        console.warn(`‚ö†Ô∏è SAFETY SKIP: User ${userId} already has picks!`);
                        continue;
                    }

                    // Create default picks structure
                    const defaultPicks = {
                        userId: userId,
                        weekNumber: 3,
                        submittedAt: new Date().toISOString(),
                        userName: 'Auto-Generated Default',
                        mnfTotalPoints: 21 // Default MNF points
                    };

                    // Add picks: home teams with confidence 1-16 in order
                    gameIds.forEach((gameId, index) => {
                        const game = bibleData[gameId];
                        defaultPicks[gameId] = {
                            winner: game.h, // Home team
                            confidence: index + 1 // 1-16 in order
                        };
                    });

                    // SAFE OPERATION: Only set() for confirmed missing users
                    batch.set(userPicksRef, defaultPicks);
                    generatedCount++;
                    console.log(`‚úÖ Queued default picks for user: ${userId}`);
                }

                if (generatedCount === 0) {
                    status.textContent = '‚úÖ SAFE: No picks needed to be generated';
                    return;
                }

                status.textContent = `üíæ Committing ${generatedCount} new pick documents...`;

                // Step 6: Commit batch (SAFE - only creates new documents)
                await batch.commit();

                status.textContent = `‚úÖ SUCCESS: Generated ${generatedCount} missing Week 3 pick documents!`;
                console.log(`‚úÖ Successfully created ${generatedCount} default picks documents`);

                // Reload picks to show new data
                setTimeout(() => {
                    loadWeekPicks();
                }, 2000);

            } catch (error) {
                console.error('‚ùå Error generating missing picks:', error);
                status.textContent = `‚ùå Error: ${error.message}`;
            }
        }
    </script>
</body>
</html>